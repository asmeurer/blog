<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article# " vocab="http://ogp.me/ns" lang="en">
<head>
<meta charset="utf-8">
<base href="https://asmeurer.github.io/blog/">
<meta name="description" content="My blog">
<meta name="viewport" content="width=device-width">
<title>Aaron Meurer's Blog</title>
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<link href="assets/css/ipython.min.css" rel="stylesheet" type="text/css">
<link href="assets/css/nikola_ipython.css" rel="stylesheet" type="text/css">
<meta content="#5670d4" name="theme-color">
<link rel="alternate" type="application/rss+xml" title="RSS" href="rss.xml">
<link rel="canonical" href="https://asmeurer.github.io/blog/">
<link rel="next" href="index-3.html" type="text/html">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]--><link rel="prefetch" href="posts/github-reviews-gripes/" type="text/html">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>
    <div id="container">
         
    <header id="header"><h1 id="brand"><a href="https://asmeurer.github.io/blog/" title="Aaron Meurer's Blog" rel="home">

        <span id="blog-title">Aaron Meurer's Blog</span>
    </a></h1>

        

        
    <nav id="menu"><ul>
<li class="active"><a href=".">Blog <span class="sr-only">(active)</span></a></li>
                <li><a href="about">About</a></li>
                <li><a href="work">Work</a></li>
                <li><a href="archive.html">Archives</a></li>
                <li><a href="rss.xml">RSS</a></li>
    
    
    </ul></nav></header><main id="content"><div class="postindex">
    <article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="posts/github-reviews-gripes/" class="u-url">GitHub Reviews Gripes</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn">
                Aaron Meurer
            </span></p>
            <p class="dateline"><a href="posts/github-reviews-gripes/" rel="bookmark"><time class="published dt-published" datetime="2016-10-05T19:12:16-05:00" title="2016-10-05 19:12">2016-10-05 19:12</time></a></p>
                <p class="commentline">
        
    <a href="posts/github-reviews-gripes/#disqus_thread" data-disqus-identifier="cache/posts/github-reviews-gripes.html">Comments</a>


        </p>
</div>
    </header><div class="e-content entry-content">
    <div>
<p>GitHub
<a href="https://github.com/blog/2256-a-whole-new-github-universe-announcing-new-tools-forums-and-features">recently</a> rolled
out a new feature on their pull requests called "Reviews". The feature is (in
theory), something that I've
been
<a href="https://groups.google.com/d/msg/sympy/KJwDwT_P6Lw/27ha6ipuBwAJ">asking for</a>.
However, it really falls short in a big way, and I wanted to write down my
gripes with it, in the hopes that it spurs someone at GitHub to fix it.</p>
<p>If you don't know, GitHub has had, for some time, a feature called "pull
requests" ("PRs"), which lets you quite nicely show the diff and commit
differences between two branches before merging them. People can comment on
pull requests, or on individual lines in the diff. Once an administrator feels
that the pull request is "ready", they can click a button and have the branch
automatically merged.</p>
<p>The concept seems super simple
in <a href="https://en.wikipedia.org/wiki/Hindsight_bias">retrospect</a>, but this
feature completely revolutionized open source software development. It really
is the bread and butter of GitHub. I would argue that this one single feature
has made GitHub the (<em>the</em>) primary hosting site for open source software.</p>
<p>Aside from being an awesome idea, GitHub's trademark with pull requests, along
with their other features, has been absolute simplicity in implementation.
GitHub Reviews marks, by my estimation, the first major feature released by
GitHub that completely and utterly lacks in this execution of simplicity.</p>
<p>Let's look at what Reviews is. When the feature first came out, I had a hard
time figuring out how it even worked (the
poor
<a href="https://twitter.com/asmeurer/status/776125249712717824">release date docs</a>
didn't help here either).</p>
<p>Basically, at the bottom of a pull request, you now see this</p>
<p><img src="reviews1.png" width="788"></p>
<p>Clicking the "Add your review" button takes you to the diff page (first gripe:
why does it move you to the diff page?), and opens this dialog</p>
<p><img src="reviews2.png" width="1020"></p>
<p>"OK", you might think, "this is simple enough. A review is just a special
comment box where I can approve or reject a pull request." (This is basically
the feature that I've been wanting, the ability to approve or reject pull
requests.) And if you thought that, you'd be wrong.</p>
<p>The simplest way I can describe a review, having played with it, is that it is
a distinct method of commenting on pull requests and on lines of diffs of pull
requests. Distinct, that is, from the methods that <strong>already exist</strong> in the
GitHub pull requests feature. That's right. There are now two ways to comment
on a pull request (or on a line in a pull request). There's the old way, which
involves typing text into the box at the bottom of the main pull request page
(or on a line, and then pressing "Add a single comment"), and the new way,
which involves clicking a special button at the top of the diff view (and the
diff view only) (or by clicking a line in the diff and
clicking "Start a review").</p>
<p>How do these two ways of the extremely simple task of commenting differ from
one another? Two ways. One, with the old way, when you comment on a PR (or
line), the comment is made immediately. It's saved instantly to the GitHub
database, and a notification email is sent to everyone subscribed to the PR.
With the new way, the comment is <strong>not</strong> made immediately.  Instead, you start
a "review", which postpones all comments from being published until you scroll
to the top and press a button ("Review changes"). <strong>Did you forget to scroll
to the top and press that button? Oh well, your comments never got sent to
anyone.</strong></p>
<p>Now, I've been told by some people that delayed commenting is a feature that
they like. I can see how fewer total emails could be nice. <strong>But if you just
want a way to delay comments, why do you need distinct commenting UIs?</strong>
Couldn't the same thing be achieved via a user setting (I highly suspect that
any given person will either like or dislike delayed commenting universally)?
Or with a checkbox next to the comment button, like "delay notifications for
this comment"? You can probably guess by now which of the two commenting
systems I prefer. But guess what happens when I press the "Cmd-Enter" keyboard
shortcut that's been hard-wired into my brain to submit a comment? I'll give
you a hint: the
result
<a href="https://twitter.com/asmeurer/status/781949163562999808">does not make me happy</a>.</p>
<p>The second distinction between normal, old-fashioned commenting and the
new-fangled reviews system is that when you finalize a review, you can elect
to "approve" or "reject" the pull request. This approval or rejection gets set
as a special status on the pull request. This status, for me personally, is
the only feature here that I've been wanting. It turns out, however, that it's
completely broken, and useless.</p>
<p>Here's my problem. We have, at the time of
writing, <a href="https://github.com/sympy/sympy/pulls">382 open pull requests</a> in
SymPy. A lot of these are old, and need to be triaged. But the problem from my
point of view is the new ones. When I look through the list of pull requests,
I want to be able to know, at a glance, which ones are "reviewable". For me,
this means two things</p>
<ol>
<li><p>The tests pass.</p></li>
<li><p>No other reviewer (myself included) has already requested changes, which
still need to be made by the PR author.</p></li>
</ol>
<p>Point 1 is really easy to see. In the pull request list, there is a nice green
checkmark if Travis passed and a red X if it failed.</p>
<p><img src="prlist.png" width="608"></p>
<p>The second point is a disaster. Unfortunately, there's no simple way to do
this. You might suggest adding a special label, like "Needs changes", to pull
requests that have been reviewed. The problem with this is that the label
won't go away when the changes have been made. And to worsen things, people
who don't have push access (in the list above, only two PR authors have push
access, and one of them is me), cannot add or remove labels on pull requests.</p>
<p>Another thing
that
<a href="https://twitter.com/asmeurer/status/771393023389339649">has been suggested to me</a> is
an external "review" service that sets a status for a review. The problem with
this (aside from the fact that I couldn't find one that actually did the very
simple thing that I wanted), is that you now have to teach all your pull
request reviewers to use this service. You might as well forget about it.</p>
<p>Having a first-class way in GitHub for reviewers to say "I approve these
changes" or "I don't approve these changes" would be a huge boon, because then
everyone would use it.</p>
<p>So great right, this new Reviews feature is exactly what you want, you say.
You can now approve or reject pull requests.</p>
<p>Well no, because GitHub managed to overengineer this feature to the point of
making it useless. This completely simple feature. All they had to do was
extend the status UI and add a simple "I approve/I reject" button. If they did
that, it would have worked perfectly.</p>
<p>Here are the problems. First, the pull request list has no indication of
review status. Guess which pull requests in the above screenshot have reviews
(and which are positive and which are negative). You can't tell (for example,
the last one in the list has a negative review). If they were actually treated
like statuses, like the UI suggests that they would, you would at least see an
X on the ones that have negative reviews (positive reviews I'm much less
worried about; most people who review PRs have merge access, so if they like
the PR they can just merge it). I would suggest to GitHub to add, next to the
status checkbox, a picture of everyone who's made a review on the PR, with a
green checkmark or red X to indicate the type of review. Also, add buttons
(<strong>buttons</strong>, not just buried advanced search options) to filter by reviews.</p>
<p>OK, so that's a minor UI annoyance, but it gets worse. Next on the docket, <strong>you
can't review your own pull requests.</strong> It's not allowed for some reason.</p>
<p><img src="reviews3.png" width="411"></p>
<p>Now why would you want to review your own pull request, you might ask? Aren't
you always going to "approve" your own PR? Well, first off, no. There is such
a thing as
a <a href="http://ben.balter.com/2015/12/08/types-of-pull-requests/">WIP PR</a>. The
author setting a negative review on his own PR would be a great way to
indicate WIP status (especially given the way reviews work, see my next
gripe). Secondly, the "author" of a pull request is just the person who
clicked the "New pull request" button. That's not necessarily the only person
who has changes in the pull request. Thanks to the magic of how git works,
it's quite easy to have a pull request with commits from many people. Multiple
people pushing to a shared branch, with a matching pull request for discussion
(and easy viewing of new commits and diff) is a valid and useful workflow
(it's the only one I know of that works for writing collaborative prose). For
the <a href="https://github.com/sympy/sympy-paper">SymPy paper</a>, I wanted to use
GitHub Reviews to sign off on a common branch, but since I'm the one who
started the pull request, I couldn't do it.</p>
<p>Next gripe, and this, I want to stress, makes the whole feature completely
useless for my needs: <strong>reviews do not reset when new commits are pushed</strong>.
Now, I just outlined above two use-cases where you might want to do a review
that doesn't reset (marking WIP, and marking approval, although the second is
debatable), but both of those can easily be done by other means, like editing
the title of the PR, or old-fashioned commenting. The whole point of Reviews
(especially negative reviews), you'd think, would be to indicate to people
that the pull request, as it currently stands, needs new changes. A negative
review is like failing your "human" test suite.</p>
<p>But unlike your automated test suite, which reset and get a new go every time
you push a change (because hey, who knows, maybe the change ACTUALLY FIXED THE
ISSUE), reviews do not reset, unless the original reviewers explicitly change
them. So my dream of being able to glance at the pull request list and see
which PRs need changes has officially
been <a href="https://en.wiktionary.org/wiki/pipe_dream">piped</a>. Even if the list
actually showed what PRs have been reviewed, it would be a lie, because as
soon as the PR author pushes a change, the review status becomes potentially
outdated.</p>
<p>Now, given the rocky start that this whole feature has had, I figured that
this was probably just a simple bug. But after I reported it to GitHub,
they've informed me that this is in fact <em>intended behavior</em>.</p>
<p>To make things worse, GitHub has another feature with Reviews,
called
<a href="https://help.github.com/articles/approving-a-pull-request-with-required-reviews/">required reviews</a>.
You can make it so that every pull request must receive at least one positive
review and zero negative reviews before it can be merged (go to the branch
settings for your repository). This works similar to required status checks,
which make it so that your tests must pass before a PR can be merged. In
practice, this means you need zero negative reviews, since anyone with push
access could just do a positive review before merging (although annoyingly,
you have to actually manually do it; IMHO, just requiring zero negative
reviews should be sufficient, since merging is implicitly a positive review).</p>
<p>Now, you can see that the above "feature" of reviews not resetting breaks the
whole thing. If someone negative reviews a PR, that one person has to go in
and change their review before it can be merged. And even if the author pushes
new changes to fix the issues outlined in the review, the PR cannot be merged
until the reviewer resets it. So this actually makes the reviewing situation
<em>worse</em>, because now anyone who reviews a pull request at any point in time
has to go through with it all the way to the merge. I can't go to a PR that
someone requested changes for, which were later made by the author, and merge
it. I have to ping the reviewer and get them to change their review first.
Needless to say, we do not have this feature enabled for SymPy's repo.</p>
<p>I think I maybe see the intended use-case here. You want to make it so that
people's reviews are not forgotten or ignored. But that's completely foreign
to my own problems. I trust the SymPy community, and the people who have push
access to do due diligence before merging a pull request. And if a bad change
gets in, we can revert it. Maybe this feature matters more for projects that
continuously deploy. Likely most of the code internal at GitHub works like
that. But guess what GitHub, most of the code <em>on</em> GitHub does <em>not</em> work like
that. You need to rethink this feature to support more than just your
use-cases.</p>
<p>I think starting simple, say, just a simple "approve/reject" button on each
PR, which just adds an icon, and that's it, would have been a better approach.
Then they could have listened to the feedback on what sorts of things people
wanted it to be able to do (like setting a status, or showing up in the search
list, or "delayed commenting" if that's really what people want). This is how
GitHub used to do things. It's frustrating to see a feature implemented that
doesn't (yet) do quite what you want, but it's even more frustrating to see a
feature implemented that does all the things that you don't want.</p>
<h2>Summary</h2>
<p>Yes, I'm a little mad here. I hope you enjoyed my rant. Here are what I see as
the problems with the "Reviews" feature. I don't know how to fix these
problems (I'm not a UI/UX guy. GitHub supposedly hires them, though).</p>
<ul>
<li><p>There are now two distinct ways to comment on a PR (delayed and non-delayed).
There should be one (say, with a checkbox to delay commenting).</p></li>
<li><p>If you insist on keeping delayed commenting, let me turn it off by default
(default = the Cmd-Enter keyboard shortcut).</p></li>
<li><p>The reviews button is buried on the diff page. I would put it under the
main PR comment box, and just reuse the same comment box.</p></li>
<li><p>Reviews should show up in the pull request list. They should be filterable
with a nice UI.</p></li>
<li><p>Let me review my own pull requests. These can be excluded from required
reviews (that makes sense to me). Beyond that, there's no reason this
shouldn't be allowed.</p></li>
<li><p>Don't require a positive review for required reviews, only zero negative
reviews. Merging a PR is implicitly positively reviewing it.</p></li>
<li><p>Allow reviews to reset when new commits are pushed.</p></li>
</ul>
<p>I get that the last point may not be what everyone wants. But GitHub needs to
think about UI, and defaults here. Right now, the UI looks like reviews are
like statuses, but they actually aren't because of this.</p>
<p>I am dispirited to see GitHub release such a broken feature, but even the best
trip up sometimes. I'm not yet calling "doom" on GitHub. Everyone has
their <a href="https://en.wikipedia.org/wiki/Apple_USB_Mouse">hockey puck mice</a>. I'm
actually hopeful that they can fix these issues, and implement a feature that
makes real headway into helping me solve one of my biggest problems on GitHub
right now, the reviewing of pull requests.</p>
</div>
    </div>
    </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="posts/tuples/" class="u-url">Tuples</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn">
                Aaron Meurer
            </span></p>
            <p class="dateline"><a href="posts/tuples/" rel="bookmark"><time class="published dt-published" datetime="2016-09-21T21:33:14-05:00" title="2016-09-21 21:33">2016-09-21 21:33</time></a></p>
                <p class="commentline">
        
    <a href="posts/tuples/#disqus_thread" data-disqus-identifier="cache/posts/tuples.html">Comments</a>


        </p>
</div>
    </header><div class="e-content entry-content">
    <div>
<p>Today, David Beazley made some tweets:</p>
<blockquote class="twitter-tweet" data-conversation="none" data-lang="en">
<p lang="en" dir="ltr">At the bookstore. I'll admit I judge Python books by their tuple description. "Read only list?"  Back on the shelf.  Nope.</p>— David Beazley (@dabeaz) <a href="https://twitter.com/dabeaz/status/778634205395845120">September 21, 2016</a>
</blockquote>

<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script><blockquote class="twitter-tweet" data-conversation="none" data-lang="en">
<p lang="en" dir="ltr">Usually there's a sentence nearby "sometimes you need a read only list." No. No, I haven't. Not in 20 years. Not even once. Sorry.</p>— David Beazley (@dabeaz) <a href="https://twitter.com/dabeaz/status/778635637457088512">September 21, 2016</a>
</blockquote>

<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script><blockquote class="twitter-tweet" data-conversation="none" data-lang="en">
<p lang="en" dir="ltr">My main objection is that "read only list" is a lazy description lacking thought. A red flag for every other topic that might be covered.</p>— David Beazley (@dabeaz) <a href="https://twitter.com/dabeaz/status/778639979052498944">September 21, 2016</a>
</blockquote>

<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script><p>There are quite a few good responses to these tweets, both from David and from
others (and from yours truly). I recommend reading the the thread (click on
the <a href="https://twitter.com/dabeaz/status/778634205395845120">first tweet</a> above).</p>
<p>Now to start off, I want to say that I respect the hell out of David Beazley.
The guy literally <a href="http://www.dabeaz.com/cookbook.html">wrote the book</a> on
Python, and he knows way more about Python than I ever will. He's also one of
the most entertaining Python people you can
<a href="https://twitter.com/dabeaz">follow on Twitter</a>. But hey, that doesn't mean I
can't disagree sometimes.</p>
<h2>List vs. Tuple. Fight!</h2>
<p>As you probably know, there are two "array" datatypes in Python, <code>list</code> and
<code>tuple</code>.<sup id="fnref:list"><a class="footnote-ref" href="posts/tuples/#fn:list" rel="footnote">1</a></sup> The primary difference between the two is that lists are <em>mutable</em>,
that is you can change their entries and length after they are created, with
methods like <code>.append</code> or <code>+=</code>. Tuples, on the other hand, are <em>immutable</em>.
Once you create one, you cannot change it. This makes the implementation
simpler (and hence faster, although don't let anyone tell you you should use a
tuple just because it's faster). This, as
<a href="http://nedbatchelder.com/blog/201608/lists_vs_tuples.html">Ned Batchelder</a>
points out, is the only technical difference between the two.</p>
<p>The the idea that particularly bugs me here is that tuples are primarily
useful as "record" datatypes.</p>
<blockquote class="twitter-tweet" data-conversation="none" data-lang="en">
<p lang="en" dir="ltr"><a href="https://twitter.com/AllenDowney">@AllenDowney</a> Better than "read-only-list." ;-).   Mainly looking for the tuple-as-record description. That's often what's missing.</p>— David Beazley (@dabeaz) <a href="https://twitter.com/dabeaz/status/778685294593716224">September 21, 2016</a>
</blockquote>

<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script><p>Tuples are awesome for records. This is both by design—since they have a
fixed shape, the positions in a tuple can be "fixed" values, and by convention—if a
Python programmer sees parentheses instead of square brackets, he is more
likely to see the object as "record-like". The <code>namedtuple</code> object in the standard library
takes the record idea further by letting you actually name the fields:</p>
<pre class="code literal-block"><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">namedtuple</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">person</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s">'Person'</span><span class="p">,</span> <span class="s">'name, age'</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">person</span><span class="p">(</span><span class="s">'Aaron'</span><span class="p">,</span> <span class="mi">26</span><span class="p">)</span>
<span class="n">Person</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">'Aaron'</span><span class="p">,</span> <span class="n">age</span><span class="o">=</span><span class="mi">26</span><span class="p">)</span>
</pre>


<p>But is that really the <em>only</em> place you'd want to use a tuple over a list?</p>
<p>Consider five other places you might encounter a tuple in Python, courtesy of
Allen Downey:</p>
<blockquote class="twitter-tweet" data-conversation="none" data-lang="en">
<p lang="en" dir="ltr"><a href="https://twitter.com/dabeaz">@dabeaz</a> (1) tuple assignment (2) multiple return values (3) *args (4) output from zip, enumerate, etc (5) key in dictionary</p>— Allen Downey (@AllenDowney) <a href="https://twitter.com/AllenDowney/status/778691102094176257">September 21, 2016</a>
</blockquote>

<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script><p>In code these look like:</p>
<ol>
<li>
<p><strong>Multiple assignments:</strong></p>
<pre class="code literal-block">&gt;&gt;&gt; (a, b) = 1, 2
</pre>


<p>(yes, the parentheses are optional here, as they are in many places where a
tuple can be used, but this is still a tuple, or at least it looks like one ;)</p>
</li>
<li>
<p><strong>Multiple return values:</strong></p>
<p>For example,
<a href="https://docs.python.org/3/library/os.html#os.walk"><code>os.walk</code></a>. This is
for the most part a special case of using tuples as records.</p>
</li>
<li>
<p><strong><code>*args</code>:</strong></p>
<pre class="code literal-block">&gt;&gt;&gt; def f(*args):
...     print(type(args), args)
...
&gt;&gt;&gt; f(1, 2, 3)
&lt;class 'tuple'&gt; (1, 2, 3)
</pre>


<p>Arbitrary positional function arguments are always stored as a <code>tuple</code>.</p>
</li>
<li>
<p><strong>Return value from builtins <code>zip</code>, <code>enumerate</code>, etc.:</strong></p>
<pre class="code literal-block">&gt;&gt;&gt; for i in zip(range(3), 'abc'):
...     print(i)
...
(0, 'a')
(1, 'b')
(2, 'c')
&gt;&gt;&gt; for i in enumerate('abc'):
...     print(i)
...
(0, 'a')
(1, 'b')
(2, 'c')
</pre>


<p>This also applies to the combinatoric generators in
<a href="https://docs.python.org/3.6/library/itertools.html">itertools</a> (like
<code>product</code>, <code>combinations</code>, etc.)</p>
</li>
<li>
<p><strong>Dictionary keys:</strong></p>
<pre class="code literal-block">&gt;&gt;&gt; {
...     (0, 0): '.',
...     (0, 1): ' ',
...     (1, 0): '.',
...     (1, 1): ' ',
... }
{(0, 1): ' ', (1, 0): '.', (0, 0): '.', (1, 1): ' '}
</pre>


</li>
</ol>
<p>This last one I find to be very important. You could arguably use a list for
the first four of Allen Downey's points<sup id="fnref:assign"><a class="footnote-ref" href="posts/tuples/#fn:assign" rel="footnote">2</a></sup> (or Python could have, if it wanted to). But it
is
<a href="https://asmeurer.github.io/blog/posts/what-happens-when-you-mess-with-hashing-in-python/">impossible</a>
to meaningfully hash a mutable data structure in Python, and hashability is a
requirement for dictionary keys.</p>
<p>However, be careful. Not all tuples are hashable. Tuples can contain
anything, but only tuples of immutable values are hashable. Consider<sup id="fnref:TypeError"><a class="footnote-ref" href="posts/tuples/#fn:TypeError" rel="footnote">4</a></sup></p>
<pre class="code literal-block"><span class="o">&gt;&gt;&gt;</span> <span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">t</span>
<span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
</pre>


<p>Such tuples are not hashable, and cannot be used as dictionary keys.</p>
<pre class="code literal-block"><span class="o">&gt;&gt;&gt;</span> <span class="nb">hash</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
  <span class="n">File</span> <span class="s">"&lt;ipython-input-39-36822ba665ca&gt;"</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
    <span class="nb">hash</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="ne">TypeError</span><span class="p">:</span> <span class="n">unhashable</span> <span class="nb">type</span><span class="p">:</span> <span class="s">'list'</span>
</pre>


<h2>Why is <code>list</code> the Default?</h2>
<p>My second gripe here is this notion that your default ordered collection
object in Python should be <code>list</code>. <code>tuples</code> are only to be used as "records",
or if you suspect <em>might</em> want to use it as a dictionary key. First off, you
never know when you'll want something to be hashable. Both dictionary keys and
<code>sets</code> require hashability. Suppose you want to de-duplicate a collection of
sequences. If you represent the sequences with <code>list</code>, you'll either have to
write a custom loop that checks for duplicates, or manually convert them to
<code>tuple</code> and throw them in a <code>set</code>. If you start with <code>tuple</code>, you don't have
to worry about it (again, assuming the entries of the tuples are all hashable
as well).</p>
<p>Consider another usage of tuples, which I consider to be
important, namely tree structures. Say you wanted a simple representation of a
Python syntax tree. You might represent <code>1 - 2*(-3 + 4)</code> as</p>
<pre class="code literal-block"><span class="p">(</span><span class="s">'-'</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="s">'*'</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="s">'+'</span><span class="p">,</span> <span class="p">(</span><span class="s">'-'</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="mi">4</span><span class="p">)))</span>
</pre>


<p>This isn't really a record. The meaning of the entries in the tuples is
determined by the first value of the tuple, not position. In this example, the length
of the tuple also signifies meaning (binary vs. unary <code>-</code>).</p>
<p>If this looks familiar to you, it's because this is how the language Lisp
represents all programs. This is a common pattern.
<a href="http://dask.pydata.org/en/latest/graphs.html">Dask graphs</a> use tuples and
dictionaries to represent computations.
<a href="http://docs.sympy.org/latest/tutorial/manipulation.html">SymPy expression trees</a>
use tuples and Python classes to represent symbolic mathematical expressions.</p>
<p>But why use tuples over lists here? Suppose you had an object like the one
above, but using lists: <code>['-', 1, ['*', 2, ['+', ['-', 3], 4]]]</code>. If you
discover you need to use this as a dictionary key, or want to put it in a
<code>set</code>, you would need to convert this to a hashable object. To do this you
need to write a function that recursively converts each <code>list</code> to a <code>tuple</code>.
See how long it takes you to write that function correctly.</p>
<h2>Mutability is Bad</h2>
<p>More to the point, however, mutability is bad. I counted 12 distinct methods
on <code>list</code> that mutate it (how many can you remember off the top of your
head?<sup id="fnref:mutate"><a class="footnote-ref" href="posts/tuples/#fn:mutate" rel="footnote">3</a></sup>). <em>Any</em> function that gets access to a list can mutate it,
using any one of these methods. All it takes is for someone to forget that
<code>+=</code> mutates a list (and that they should copy it first) for code completely
distant from the origin definition to cause issues. The hardest bug I ever
debugged had a three character
<a href="https://github.com/inducer/pudb/commit/b979fc5909c8d731eb907fc25f4e97904fb7cbbd">fix</a>,
adding <code>[:]</code> to copy a global list that I was (accidentally) mutating. It took
me a several hour airplane ride and some deep dark magic that I'll leave for
another blog post to discover the source of my problems (the problems I was
having appeared to be quite distant from the actual source).</p>
<h2>A Better "Default"</h2>
<p>I propose that Python code in general would be vastly improved if people used
<code>tuple</code> as the default ordered collection, and only switched to <code>list</code> if
mutation was necessary (it's less necessary than you think; you can always
copy a tuple instead of mutating it). I agree with David Beazley that you
don't "sometimes need a read only list". Rather, you "sometimes need a
writable tuple".</p>
<p>This makes more sense than defaulting to <code>list</code>, and only switching to <code>tuple</code>
when hashability is needed, or when some weird "rule of thumb" applies that
says that you should use <code>tuple</code> if you have a "record". Maybe there's a good
reason that <code>*args</code> and almost all builtin and standard library functions
return tuples instead of lists. It's harder to accidentally break someone
else's code, or have someone else accidentally break your code, when your data
structures are immutable.</p>
<h2>Footnotes</h2>
<div class="footnote">
<hr>
<ol>
<li id="fn:list">
<p>I want to avoid saying "a tuple is an immutable list", since "list"
can be interpreted in two ways, as an English word meaning "ordered
collection" (in
which case, the statement is true), or as the Python type <code>list</code> (in which
case, the statement is false—<code>tuple</code> is not a subclass of <code>list</code>). <a class="footnote-backref" href="posts/tuples/#fnref:list" rev="footnote" title="Jump back to footnote 1 in the text">↩</a></p>
</li>
<li id="fn:assign">
<p>Yes,</p>
<pre class="code literal-block">&gt;&gt;&gt; [a, b] = 1, 2
</pre>


<p>works. <a class="footnote-backref" href="posts/tuples/#fnref:assign" rev="footnote" title="Jump back to footnote 2 in the text">↩</a></p>
</li>
<li id="fn:mutate">
<p></p>
<div id="spoiler" style="display:none">
<code>__delitem__</code>, <code>__iadd__</code>, <code>__imul__</code>, <code>__setitem__</code>, <code>append</code>, <code>clear</code>, <code>extend</code>, <code>insert</code>,
<code>pop</code>, <code>remove</code>, <code>reverse</code>, and <code>sort</code>.
</div>
<button title="Click to show/hide content" type="button" onclick="if(document.getElementById('spoiler') .style.display=='none')
{document.getElementById('spoiler')
.style.display=''}else{document.getElementById('spoiler')
.style.display='none'}">Show/hide answer</button> <a class="footnote-backref" href="posts/tuples/#fnref:mutate" rev="footnote" title="Jump back to footnote 3 in the text">↩</a>
</li>
<li id="fn:TypeError">
<p>One of the tweets from the conversation:</p>
<p></p>
<blockquote class="twitter-tweet" data-conversation="none" data-lang="en">
<p lang="en" dir="ltr"><a href="https://twitter.com/asmeurer">@asmeurer</a> <a href="https://twitter.com/AllenDowney">@AllenDowney</a> As yes:<br><br>t = (1,2, [3, 4])<br>t[2] += [5,6]<br><br>;-)</p>— David Beazley (@dabeaz) <a href="https://twitter.com/dabeaz/status/778697399975813120">September 21, 2016</a>
</blockquote> <script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script><p>This is similar to this example. But
it turns out this one doesn't work:</p>
<pre class="code literal-block">&gt;&gt;&gt; t = (1,2, [3, 4])
&gt;&gt;&gt; t[2] += [5,6]
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: 'tuple' object does not support item assignment
</pre>


<p>I have no idea why. It seems to me that it should work. <code>t[2]</code> is a list
and <code>list</code> has <code>__iadd__</code> defined. It seems that Python gets kind of weird
about things on the left-hand side of an assignment. <strong>EDIT:
<a href="http://stackoverflow.com/a/29747466/161801">Here's</a> why.</strong> <a class="footnote-backref" href="posts/tuples/#fnref:TypeError" rev="footnote" title="Jump back to footnote 4 in the text">↩</a></p>
</li>
</ol>
</div>
</div>
    </div>
    </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="posts/moving-away-from-python-2/" class="u-url">Moving Away from Python 2</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn">
                Aaron Meurer
            </span></p>
            <p class="dateline"><a href="posts/moving-away-from-python-2/" rel="bookmark"><time class="published dt-published" datetime="2016-05-19T14:00:00-04:00" title="2016-05-19 14:00">2016-05-19 14:00</time></a></p>
                <p class="commentline">
        
    <a href="posts/moving-away-from-python-2/#disqus_thread" data-disqus-identifier="cache/posts/moving-away-from-python-2.html">Comments</a>


        </p>
</div>
    </header><div class="e-content entry-content">
    <div>
<p>About a month ago I tweeted this:</p>
<blockquote class="twitter-tweet" data-lang="en">
<p lang="en" dir="ltr">Thought: get the maintainers of a bunch of big Python libraries to sign something saying that they WILL drop Python 2.7 support in 2020.</p>— Aaron Meurer (@asmeurer) <a href="https://twitter.com/asmeurer/status/712304912428875776">March 22, 2016</a>
</blockquote>

<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script><p><strong>EDIT: Some people have started working on making this happen. See
<a href="https://python3statement.github.io/">https://python3statement.github.io/</a>.</strong></p>
<p>For those of you who don't know, Python 2.7 is
<a href="https://docs.python.org/devguide/#status-of-python-branches">slated</a> to reach
end-of-life in 2020 (originally, it was slated to end in 2015, but it was
extended in 2014, due to the extraordinary difficulty of moving to a newer
version). "End-of-life" means absolutely no more support from the core Python
team, even for security updates.</p>
<p>I'm writing this post because I want to clarify why I think this should be
done, and to clear up some misconceptions, the primary one being that this
represents library developers being antagonistic against those who want or
have to use Python 2.</p>
<p>I'm writing this from my perspective as a library developer. I'm the lead
developer of <a href="http://www.sympy.org/">SymPy</a>, and I have sympathies for
developers of other libraries.<sup id="fnref:sympy"><a class="footnote-ref" href="posts/moving-away-from-python-2/#fn:sympy" rel="footnote">1</a></sup> I say this because my idea may seem a bit
in tension with "users" (even though I hate the "developer/user" distinction).</p>
<h3>Python 2</h3>
<p>There are a few reasons why I think libraries should drop (and announce that
they will drop) Python 2 support by 2020 (actually earlier, say 2018 or 2019,
depending on how core the library is).</p>
<p>First, library developers have to be the leaders here. This is apparent from
the historical move to Python 3 up to this point. Consider the three (not
necessarily disjoint) classes of people: CPython core developers, library
developers, and users. The core developers were the first to move to Python 3,
since they were the ones who wrote it. They were also the ones who provided
the messaging around Python 3, which has varied over time. In my opinion, it
should have been and should be more forceful.<sup id="fnref:core"><a class="footnote-ref" href="posts/moving-away-from-python-2/#fn:core" rel="footnote">2</a></sup> Then you have the library
developers and the users. A chief difference here is that users are probably
going to be using only one version of Python. In order for them to switch that
version to Python 3, all the libraries that they use need to support it. This
took some time, since library developers saw little impetus to support Python
3 when no one was using it (Catch 22), and to worsen the situation, versions
of Python older than 2.6 made
<a href="https://asmeurersympy.wordpress.com/2013/08/22/python-3-single-codebase-vs-2to3/">single codebase compatibility</a>
almost impossible.</p>
<p>Today, though, <a href="http://py3readiness.org/">almost all libraries</a> support Python
3, and we're reaching a point where those that don't have
forks that do.</p>
<p>But it only happened <em>after</em> the library developers transitioned. I believe
libraries need to be the leaders in moving away from Python 2 as well. It's
important to do this for a few reasons:</p>
<ul>
<li>
<p>Python 2.7 support ends in 2020. That means all updates, including security
  updates. For all intents and purposes, Python 2.7 becomes an insecure
  language to use at that point in time.</p>
</li>
<li>
<p>Supporting two major versions of Python is technical debt for every project
  that does it. While writing cross compatible code is
  <a href="http://python-future.org/">easier than ever</a>, it still remains true that
  you have to remember to add <code>__future__</code> imports to the top of every file,
  to import all relevant builtins from your compatibility file or library, and
  to run all your tests in both Python 2 and 3. Supporting both versions is a
  major cognitive burden to library developers, as they always have to be
  aware of important differences in the two languages. Developers on any
  library that does anything with strings will need to understand how things
  work in both Python 2 and 3, and the often obscure workarounds required for
  things to work in both (pop quiz: how do you write Unicode characters to a
  file in a Python 2/3 compatible way?).</p>
</li>
<li>
<p>Some of Python 3's
  <a href="https://asmeurer.github.io/python3-presentation/slides.html">new syntax features</a>
  (i.e., features that are impossible to use in Python 2) only matter for
  library developers. A great example of this is
  <a href="https://www.python.org/dev/peps/pep-3102/">keyword-only arguments</a>. From an
  API standpoint, almost every instance of keyword arguments should be
  implemented as keyword-only arguments. This avoids mistakes that come from
  the antipattern of passing keyword arguments without naming the keyword, and
  allows the argspec of the function to be expanded in the future without
  breaking API.<sup id="fnref:swift"><a class="footnote-ref" href="posts/moving-away-from-python-2/#fn:swift" rel="footnote">3</a></sup></p>
</li>
</ul>
<p>The second reason I think library developers should agree to drop Python 2
support by 2020 is completely selfish. A response that I heard on that tweet
(as well as elsewhere), was that libraries should provide carrots, not sticks.
In other words, instead of forcing people off of Python 2, we should make them
want to come to Python 3. There are some issues with this argument. First,
Python 3 already has
<a href="https://asmeurer.github.io/python3-presentation/slides.html">tons of carrots</a>.
Honestly, not being terrible at Unicode ought to be a carrot in its own right.<sup id="fnref:unicode"><a class="footnote-ref" href="posts/moving-away-from-python-2/#fn:unicode" rel="footnote">4</a></sup></p>
<p>If you don't deal with strings, or do but don't care about those silly
foreigners with weird accents in their names, there are other major carrots as
well. For SymPy, the fact that 1/2 gives 0 in Python 2 has historically been a
major source of frustration for new users. Imagine writing out <code>1/2*x +
x**(1/2)*y*z - 3*z**2</code> and wondering why half of what you wrote just
"disappeared" (granted, this was worse before we
<a href="https://asmeurersympy.wordpress.com/2011/08/18/sqrtx-now-prints-as-sqrtx/">fixed the printers</a>).
While <code>integer/integer</code> not giving a rational number is a major
<a href="http://docs.sympy.org/latest/tutorial/gotchas.html#two-final-notes-and">gotcha</a>
for SymPy, giving a float is infinitely better than giving what is effectively
the wrong answer. Don't use strings or integers?
<a href="https://asmeurer.github.io/python3-presentation/slides.html">I've got more</a>.</p>
<p>Frankly, if these "carrots" haven't convinced you yet, then I'll wager you're
not really the sort of person who is persuaded by carrots.</p>
<p>Second, some "carrots" are impossible unless they are implemented in
libraries. While some features can be implemented in 2/3 compatible code and
only work in Python 3 (such as <code>@</code> matrix multiplication), others, such as
keyword-only arguments, can only be implemented in code that does not support
Python 2. Supporting them in Python 2 would be a net deficit of technical debt
(one can imagine, for instance, trying to support keyword-only arguments
manually using <code>**kwargs</code>, or by using some monstrous meta-programming).</p>
<p>Third, as I said, I'm selfish. Python 3 <em>does</em> have carrots, and I want them.
As long as I have to support Python 2 in my code, I can't use keyword-only
arguments, or extended argument unpacking, or async/await, or any of the
dozens of features that can't be used in cross compatible code.</p>
<p>A counterargument might be that instead of blocking users of existing
libraries, developers should create new libraries which are Python 3-only and
make use of new exciting features of Python 3 there. I agree we should do
that, but existing libraries are good too. I don't see why developers should
throw out all of a well-developed library just so they can use some Python
features that they are excited about.</p>
<h3>Legacy Python</h3>
<p>A lot of people have taken to calling Python 2
"<a href="https://twitter.com/RipLegacyPython">legacy Python</a>". This phrase is often
used condescendingly and
<a href="https://twitter.com/stephtdouglas/status/713433933040340993">angers a lot of people</a>
(and indeed, this blog post is the first time I've used it myself). However, I
think Python 2 really should be seen this way, as a "legacy" system. If you
want to use it, for whatever your reasons, that's fine, but just as you
shouldn't expect to get any of the newest features of Python, you shouldn't
expect to be able to use the newest versions of your libraries. Those
libraries that have a lot of development resources may choose to support older
Python 2-compatible versions with bug and/or security fixes. Python 2 itself
will be supported for these until 2020. Those without resources probably won't
(keep in mind that you're using open source libraries without paying money for
them).</p>
<p>I get that some people have to use Python 2, for whatever reasons. But using
outdated software comes at a cost. Libraries have borne this technical debt
for the most part thus far, but they shouldn't be expected to bear it forever.
The debt will only increase, especially as the technical opportunity cost, if
you will, of not being able to use newer and shinier versions of Python 3
grows. The burden will have to shift at some point. Those with the financial
resources may choose to offload this debt to others,<sup id="fnref:continuum"><a class="footnote-ref" href="posts/moving-away-from-python-2/#fn:continuum" rel="footnote">5</a></sup> say, by
backporting features or bugfixes to older library versions that support Python
2 (or by helping to move code to Python 3).</p>
<p>I want to end by pointing out that if you are, for whatever reason, still
using Python 2, you may be worried that if libraries become Python 3-only and
start using Python 3 features, won't that break your code? The answer is no.
Assuming package maintainers mark the metadata on their packages correctly,
tools like pip and conda will not install non-Python 2 compatible versions
into Python 2.</p>
<p>If you haven't transitioned yet, and want to know more, a good place to start
is the <a href="https://docs.python.org/3/howto/pyporting.html">official docs</a>. I also
highly recommend using <a href="http://conda.pydata.org/docs/">conda</a> environments, as
it will make it easy to separate your Python 2 code from your Python 3 code.</p>
<h4>Footnotes</h4>
<div class="footnote">
<hr>
<ol>
<li id="fn:sympy">
<p>With that being said, the opinions here are entirely my own, and are
    don't necessarily represent those of other people, nor do they
    represent official SymPy policy (no decisions have been made by the
    community about this at this time). <a class="footnote-backref" href="posts/moving-away-from-python-2/#fnref:sympy" rev="footnote" title="Jump back to footnote 1 in the text">↩</a></p>
</li>
<li id="fn:core">
<p>It often feels like core Python itself doesn't really want people to
    use Python 3. It's little things, like
    <a href="https://docs.python.org/library/">docs links</a> that redirect to Python
    2, or <a href="https://www.python.org/dev/peps/pep-0394/">PEP 394</a>, which
    still says that the <code>python</code> should always point to Python 2. <a class="footnote-backref" href="posts/moving-away-from-python-2/#fnref:core" rev="footnote" title="Jump back to footnote 2 in the text">↩</a></p>
</li>
<li id="fn:swift">
<p>In Swift, Apple's new language for iOS and OS X, function parameter
    names are effectively "keyword-only"
    <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Functions.html">by default</a>. <a class="footnote-backref" href="posts/moving-away-from-python-2/#fnref:swift" rev="footnote" title="Jump back to footnote 3 in the text">↩</a></p>
</li>
<li id="fn:unicode">
<p>As an example of this, in conda, if you use Python 2 in the root
    environment, then installing into a path with non-ASCII characters is
    unsupported. This is common on Windows, because Windows by default
    uses the user's full name as the username, and the default conda
    install path is in the user directory.</p>
<p>This is unsupported except in Python 3, because to fix the issue,
every single place in conda where a string appears would have to be
changed to use a <code>unicode</code> string in Python 2. The basic issue is that
things like <code>'π' + u'i'</code> raise <code>UnicodeDecodeError</code> in Python 2 (even
though <code>'π' + 'i'</code>, <code>u'π' + 'i'</code>, and <code>u'π' + u'i'</code> all work fine).
You can read a more in-depth description of the problem
<a href="https://github.com/sympy/sympy/pull/9692#issuecomment-126162173">here</a>.
Incidentally, this is also why you should never use <code>from __future__
import unicode_literals</code> in Python 2, in my opinion.</p>
<p>I no longer work on conda, but as far as I know, the
<a href="https://github.com/conda/conda/issues/1180">issue</a> remains unfixed.
Of course, this whole thing works just fine if conda is run in Python
3. <a class="footnote-backref" href="posts/moving-away-from-python-2/#fnref:unicode" rev="footnote" title="Jump back to footnote 4 in the text">↩</a></p>
</li>
<li id="fn:continuum">
<p>If that legitimately interests you, I
    <a href="https://twitter.com/pwang/status/712780279211884546">hear Continuum</a>
    may be able to help you. <a class="footnote-backref" href="posts/moving-away-from-python-2/#fnref:continuum" rev="footnote" title="Jump back to footnote 5 in the text">↩</a></p>
</li>
</ol>
</div>
</div>
    </div>
    </article>
</div>

        <nav class="postindexpager"><ul class="pager">
<li class="next">
                <a href="index-3.html" rel="next">Older posts</a>
            </li>
        </ul></nav><script>var disqus_shortname="asmeurer";(function(){var a=document.createElement("script");a.async=true;a.src="//"+disqus_shortname+".disqus.com/count.js";(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(a)}());</script></main><footer id="footer"><p>Contents © 2016         <a href="mailto:asmeurer@gmail.com">Aaron Meurer</a> - Powered by         <a href="http://getnikola.com" rel="nofollow">Nikola</a>         
</p>
<p xmlns:dct="https://purl.org/dc/terms/" xmlns:vcard="https://www.w3.org/2001/vcard-rdf/3.0#">
  <a rel="license" href="https://creativecommons.org/publicdomain/zero/1.0/">
    <img src="https://i.creativecommons.org/p/zero/1.0/88x31.png" style="border-style: none;" alt="CC0"></a>
</p>
            
        </footer>
</div>
    
    <div style="text-align:center">
<span class="st_twitterfollow_large" displaytext="Twitter Follow" st_username="asmeurer"></span>
<span class="st_twitter_large" displaytext="Tweet"></span>
<span class="st_googleplus_large" displaytext="Google +"></span>
<span class="st_plusone_large" displaytext="Google +1"></span>

<span class="st_email_large" displaytext="Email"></span>

</div>


    
    
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.5/styles/default.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.5/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script>
</body>
</html>
