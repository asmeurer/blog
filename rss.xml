<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="assets/xml/rss.xsl" media="all"?><rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/" version="2.0"><channel><title>Aaron Meurer's Blog</title><link>https://asmeurer.github.io/blog/</link><description>My blog</description><atom:link href="https://asmeurer.github.io/blog/rss.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><lastBuildDate>Sat, 21 May 2016 07:42:47 GMT</lastBuildDate><generator>https://getnikola.com/</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Moving Away from Python 2</title><link>https://asmeurer.github.io/blog/posts/moving-away-from-python-2/</link><dc:creator>Aaron Meurer</dc:creator><description>&lt;div&gt;&lt;p&gt;About a month ago I tweeted this:&lt;/p&gt;
&lt;blockquote class="twitter-tweet" data-lang="en"&gt;&lt;p lang="en" dir="ltr"&gt;Thought: get the maintainers of a bunch of big Python libraries to sign something saying that they WILL drop Python 2.7 support in 2020.&lt;/p&gt;— Aaron Meurer (@asmeurer) &lt;a href="https://twitter.com/asmeurer/status/712304912428875776"&gt;March 22, 2016&lt;/a&gt;&lt;/blockquote&gt;

&lt;script async src="//platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;

&lt;p&gt;&lt;strong&gt;EDIT: Some people have started working on making this happen. See
&lt;a href="https://python3statement.github.io/"&gt;https://python3statement.github.io/&lt;/a&gt;.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;For those of you who don't know, Python 2.7 is
&lt;a href="https://docs.python.org/devguide/#status-of-python-branches"&gt;slated&lt;/a&gt; to reach
end-of-life in 2020 (originally, it was slated to end in 2015, but it was
extended in 2014, due to the extraordinary difficulty of moving to a newer
version). "End-of-life" means absolutely no more support from the core Python
team, even for security updates.&lt;/p&gt;
&lt;p&gt;I'm writing this post because I want to clarify why I think this should be
done, and to clear up some misconceptions, the primary one being that this
represents library developers being antagonistic against those who want or
have to use Python 2.&lt;/p&gt;
&lt;p&gt;I'm writing this from my perspective as a library developer. I'm the lead
developer of &lt;a href="http://www.sympy.org/"&gt;SymPy&lt;/a&gt;, and I have sympathies for
developers of other libraries.&lt;sup id="fnref:sympy"&gt;&lt;a class="footnote-ref" href="https://asmeurer.github.io/blog/posts/moving-away-from-python-2/#fn:sympy" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt; I say this because my idea may seem a bit
in tension with "users" (even though I hate the "developer/user" distinction).&lt;/p&gt;
&lt;h3&gt;Python 2&lt;/h3&gt;
&lt;p&gt;There are a few reasons why I think libraries should drop (and announce that
they will drop) Python 2 support by 2020 (actually earlier, say 2018 or 2019,
depending on how core the library is).&lt;/p&gt;
&lt;p&gt;First, library developers have to be the leaders here. This is apparent from
the historical move to Python 3 up to this point. Consider the three (not
necessarily disjoint) classes of people: CPython core developers, library
developers, and users. The core developers were the first to move to Python 3,
since they were the ones who wrote it. They were also the ones who provided
the messaging around Python 3, which has varied over time. In my opinion, it
should have been and should be more forceful.&lt;sup id="fnref:core"&gt;&lt;a class="footnote-ref" href="https://asmeurer.github.io/blog/posts/moving-away-from-python-2/#fn:core" rel="footnote"&gt;2&lt;/a&gt;&lt;/sup&gt; Then you have the library
developers and the users. A chief difference here is that users are probably
going to be using only one version of Python. In order for them to switch that
version to Python 3, all the libraries that they use need to support it. This
took some time, since library developers saw little impetus to support Python
3 when no one was using it (Catch 22), and to worsen the situation, versions
of Python older than 2.6 made
&lt;a href="https://asmeurersympy.wordpress.com/2013/08/22/python-3-single-codebase-vs-2to3/"&gt;single codebase compatibility&lt;/a&gt;
almost impossible.&lt;/p&gt;
&lt;p&gt;Today, though, &lt;a href="http://py3readiness.org/"&gt;almost all libraries&lt;/a&gt; support Python
3, and we're reaching a point where those that don't have
forks that do.&lt;/p&gt;
&lt;p&gt;But it only happened &lt;em&gt;after&lt;/em&gt; the library developers transitioned. I believe
libraries need to be the leaders in moving away from Python 2 as well. It's
important to do this for a few reasons:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Python 2.7 support ends in 2020. That means all updates, including security
  updates. For all intents and purposes, Python 2.7 becomes an insecure
  language to use at that point in time.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Supporting two major versions of Python is technical debt for every project
  that does it. While writing cross compatible code is
  &lt;a href="http://python-future.org/"&gt;easier than ever&lt;/a&gt;, it still remains true that
  you have to remember to add &lt;code&gt;__future__&lt;/code&gt; imports to the top of every file,
  to import all relevant builtins from your compatibility file or library, and
  to run all your tests in both Python 2 and 3. Supporting both versions is a
  major cognitive burden to library developers, as they always have to be
  aware of important differences in the two languages. Developers on any
  library that does anything with strings will need to understand how things
  work in both Python 2 and 3, and the often obscure workarounds required for
  things to work in both (pop quiz: how do you write Unicode characters to a
  file in a Python 2/3 compatible way?).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Some of Python 3's
  &lt;a href="https://asmeurer.github.io/python3-presentation/slides.html"&gt;new syntax features&lt;/a&gt;
  (i.e., features that are impossible to use in Python 2) only matter for
  library developers. A great example of this is
  &lt;a href="https://www.python.org/dev/peps/pep-3102/"&gt;keyword-only arguments&lt;/a&gt;. From an
  API standpoint, almost every instance of keyword arguments should be
  implemented as keyword-only arguments. This avoids mistakes that come from
  the antipattern of passing keyword arguments without naming the keyword, and
  allows the argspec of the function to be expanded in the future without
  breaking API.&lt;sup id="fnref:swift"&gt;&lt;a class="footnote-ref" href="https://asmeurer.github.io/blog/posts/moving-away-from-python-2/#fn:swift" rel="footnote"&gt;3&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The second reason I think library developers should agree to drop Python 2
support by 2020 is completely selfish. A response that I heard on that tweet
(as well as elsewhere), was that libraries should provide carrots, not sticks.
In other words, instead of forcing people off of Python 2, we should make them
want to come to Python 3. There are some issues with this argument. First,
Python 3 already has
&lt;a href="https://asmeurer.github.io/python3-presentation/slides.html"&gt;tons of carrots&lt;/a&gt;.
Honestly, not being terrible at Unicode ought to be a carrot in its own right.&lt;sup id="fnref:unicode"&gt;&lt;a class="footnote-ref" href="https://asmeurer.github.io/blog/posts/moving-away-from-python-2/#fn:unicode" rel="footnote"&gt;4&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;p&gt;If you don't deal with strings, or do but don't care about those silly
foreigners with weird accents in their names, there are other major carrots as
well. For SymPy, the fact that 1/2 gives 0 in Python 2 has historically been a
major source of frustration for new users. Imagine writing out &lt;code&gt;1/2*x +
x**(1/2)*y*z - 3*z**2&lt;/code&gt; and wondering why half of what you wrote just
"disappeared" (granted, this was worse before we
&lt;a href="https://asmeurersympy.wordpress.com/2011/08/18/sqrtx-now-prints-as-sqrtx/"&gt;fixed the printers&lt;/a&gt;).
While &lt;code&gt;integer/integer&lt;/code&gt; not giving a rational number is a major
&lt;a href="http://docs.sympy.org/latest/tutorial/gotchas.html#two-final-notes-and"&gt;gotcha&lt;/a&gt;
for SymPy, giving a float is infinitely better than giving what is effectively
the wrong answer. Don't use strings or integers?
&lt;a href="https://asmeurer.github.io/python3-presentation/slides.html"&gt;I've got more&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Frankly, if these "carrots" haven't convinced you yet, then I'll wager you're
not really the sort of person who is persuaded by carrots.&lt;/p&gt;
&lt;p&gt;Second, some "carrots" are impossible unless they are implemented in
libraries. While some features can be implemented in 2/3 compatible code and
only work in Python 3 (such as &lt;code&gt;@&lt;/code&gt; matrix multiplication), others, such as
keyword-only arguments, can only be implemented in code that does not support
Python 2. Supporting them in Python 2 would be a net deficit of technical debt
(one can imagine, for instance, trying to support keyword-only arguments
manually using &lt;code&gt;**kwargs&lt;/code&gt;, or by using some monstrous meta-programming).&lt;/p&gt;
&lt;p&gt;Third, as I said, I'm selfish. Python 3 &lt;em&gt;does&lt;/em&gt; have carrots, and I want them.
As long as I have to support Python 2 in my code, I can't use keyword-only
arguments, or extended argument unpacking, or async/await, or any of the
dozens of features that can't be used in cross compatible code.&lt;/p&gt;
&lt;p&gt;A counterargument might be that instead of blocking users of existing
libraries, developers should create new libraries which are Python 3-only and
make use of new exciting features of Python 3 there. I agree we should do
that, but existing libraries are good too. I don't see why developers should
throw out all of a well-developed library just so they can use some Python
features that they are excited about.&lt;/p&gt;
&lt;h3&gt;Legacy Python&lt;/h3&gt;
&lt;p&gt;A lot of people have taken to calling Python 2
"&lt;a href="https://twitter.com/RipLegacyPython"&gt;legacy Python&lt;/a&gt;". This phrase is often
used condescendingly and
&lt;a href="https://twitter.com/stephtdouglas/status/713433933040340993"&gt;angers a lot of people&lt;/a&gt;
(and indeed, this blog post is the first time I've used it myself). However, I
think Python 2 really should be seen this way, as a "legacy" system. If you
want to use it, for whatever your reasons, that's fine, but just as you
shouldn't expect to get any of the newest features of Python, you shouldn't
expect to be able to use the newest versions of your libraries. Those
libraries that have a lot of development resources may choose to support older
Python 2-compatible versions with bug and/or security fixes. Python 2 itself
will be supported for these until 2020. Those without resources probably won't
(keep in mind that you're using open source libraries without paying money for
them).&lt;/p&gt;
&lt;p&gt;I get that some people have to use Python 2, for whatever reasons. But using
outdated software comes at a cost. Libraries have borne this technical debt
for the most part thus far, but they shouldn't be expected to bear it forever.
The debt will only increase, especially as the technical opportunity cost, if
you will, of not being able to use newer and shinier versions of Python 3
grows. The burden will have to shift at some point. Those with the financial
resources may choose to offload this debt to others,&lt;sup id="fnref:continuum"&gt;&lt;a class="footnote-ref" href="https://asmeurer.github.io/blog/posts/moving-away-from-python-2/#fn:continuum" rel="footnote"&gt;5&lt;/a&gt;&lt;/sup&gt; say, by
backporting features or bugfixes to older library versions that support Python
2 (or by helping to move code to Python 3).&lt;/p&gt;
&lt;p&gt;I want to end by pointing out that if you are, for whatever reason, still
using Python 2, you may be worried that if libraries become Python 3-only and
start using Python 3 features, won't that break your code? The answer is no.
Assuming package maintainers mark the metadata on their packages correctly,
tools like pip and conda will not install non-Python 2 compatible versions
into Python 2.&lt;/p&gt;
&lt;p&gt;If you haven't transitioned yet, and want to know more, a good place to start
is the &lt;a href="https://docs.python.org/3/howto/pyporting.html"&gt;official docs&lt;/a&gt;. I also
highly recommend using &lt;a href="http://conda.pydata.org/docs/"&gt;conda&lt;/a&gt; environments, as
it will make it easy to separate your Python 2 code from your Python 3 code.&lt;/p&gt;
&lt;h4&gt;Footnotes&lt;/h4&gt;
&lt;div class="footnote"&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id="fn:sympy"&gt;
&lt;p&gt;With that being said, the opinions here are entirely my own, and are
    don't necessarily represent those of other people, nor do they
    represent official SymPy policy (no decisions have been made by the
    community about this at this time). &lt;a class="footnote-backref" href="https://asmeurer.github.io/blog/posts/moving-away-from-python-2/#fnref:sympy" rev="footnote" title="Jump back to footnote 1 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:core"&gt;
&lt;p&gt;It often feels like core Python itself doesn't really want people to
    use Python 3. It's little things, like
    &lt;a href="https://docs.python.org/library/"&gt;docs links&lt;/a&gt; that redirect to Python
    2, or &lt;a href="https://www.python.org/dev/peps/pep-0394/"&gt;PEP 394&lt;/a&gt;, which
    still says that the &lt;code&gt;python&lt;/code&gt; should always point to Python 2. &lt;a class="footnote-backref" href="https://asmeurer.github.io/blog/posts/moving-away-from-python-2/#fnref:core" rev="footnote" title="Jump back to footnote 2 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:swift"&gt;
&lt;p&gt;In Swift, Apple's new language for iOS and OS X, function parameter
    names are effectively "keyword-only"
    &lt;a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Functions.html"&gt;by default&lt;/a&gt;. &lt;a class="footnote-backref" href="https://asmeurer.github.io/blog/posts/moving-away-from-python-2/#fnref:swift" rev="footnote" title="Jump back to footnote 3 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:unicode"&gt;
&lt;p&gt;As an example of this, in conda, if you use Python 2 in the root
    environment, then installing into a path with non-ASCII characters is
    unsupported. This is common on Windows, because Windows by default
    uses the user's full name as the username, and the default conda
    install path is in the user directory.&lt;/p&gt;
&lt;p&gt;This is unsupported except in Python 3, because to fix the issue,
every single place in conda where a string appears would have to be
changed to use a &lt;code&gt;unicode&lt;/code&gt; string in Python 2. The basic issue is that
things like &lt;code&gt;'π' + u'i'&lt;/code&gt; raise &lt;code&gt;UnicodeDecodeError&lt;/code&gt; in Python 2 (even
though &lt;code&gt;'π' + 'i'&lt;/code&gt;, &lt;code&gt;u'π' + 'i'&lt;/code&gt;, and &lt;code&gt;u'π' + u'i'&lt;/code&gt; all work fine).
You can read a more in-depth description of the problem
&lt;a href="https://github.com/sympy/sympy/pull/9692#issuecomment-126162173"&gt;here&lt;/a&gt;.
Incidentally, this is also why you should never use &lt;code&gt;from __future__
import unicode_literals&lt;/code&gt; in Python 2, in my opinion.&lt;/p&gt;
&lt;p&gt;Even though I no longer work on conda, as far as I know, the
&lt;a href="https://github.com/conda/conda/issues/1180"&gt;issue&lt;/a&gt; remains unfixed.
Of course, this whole thing works just fine if conda is run in Python
3. &lt;a class="footnote-backref" href="https://asmeurer.github.io/blog/posts/moving-away-from-python-2/#fnref:unicode" rev="footnote" title="Jump back to footnote 4 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:continuum"&gt;
&lt;p&gt;If that legitimately interests you, I
    &lt;a href="https://twitter.com/pwang/status/712780279211884546"&gt;hear Continuum&lt;/a&gt;
    may be able to help you. &lt;a class="footnote-backref" href="https://asmeurer.github.io/blog/posts/moving-away-from-python-2/#fnref:continuum" rev="footnote" title="Jump back to footnote 5 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;&lt;/div&gt;</description><guid>https://asmeurer.github.io/blog/posts/moving-away-from-python-2/</guid><pubDate>Thu, 19 May 2016 18:00:00 GMT</pubDate></item><item><title>What happens when you mess with hashing in Python</title><link>https://asmeurer.github.io/blog/posts/what-happens-when-you-mess-with-hashing-in-python/</link><dc:creator>Aaron Meurer</dc:creator><description>&lt;div&gt;&lt;p&gt;&lt;em&gt;This post is based off a Jupyter notebook I made in 2013. You can download
the original &lt;a href="https://gist.github.com/asmeurer/6046766"&gt;here&lt;/a&gt;. That notebook
was based off a
&lt;a href="https://github.com/sympy/sympy/wiki/What-happens-when-you-mess-with-hashing"&gt;wiki page&lt;/a&gt;
on the SymPy wiki, which in turn was based on
&lt;a href="https://groups.google.com/forum/#%21msg/sympy/pJ2jg2csKgU/0nn21xqZEmwJ"&gt;a message&lt;/a&gt;
to the SymPy mailing list.&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;What is hashing?&lt;/h2&gt;
&lt;p&gt;Before we start, let's have a brief introduction to hashing. A
&lt;a href="https://en.wikipedia.org/wiki/Hash_function"&gt;&lt;em&gt;hash function&lt;/em&gt;&lt;/a&gt; is a function
that maps a set of objects to a set of integers. There are many kinds of hash
functions, which satisfy many different properties, but the most important
property that must be satisfied by any hash function is that it be a function
(in the mathematical sense), that is, if two objects are equal, then their
hash should also be equal.&lt;/p&gt;
&lt;p&gt;Usually, the set of integers that the hash function maps to is much smaller
than the set of objects, so that there will be multiple objects that hash to
the same value. However, generally for a hash function to be useful, the set
of integers should be large enough, and the hash function well distributed
enough that if two objects hash to the same value, then they are very likely
to be equal.&lt;/p&gt;
&lt;p&gt;To summarize, a hash function &lt;em&gt;must&lt;/em&gt; satisfy the property:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;If two objects are equal, then their hashes should be equal.&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Additionally, a &lt;em&gt;good&lt;/em&gt; hash function should satisfy the property:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;If two objects have the same hash, then they are likely to be the same
object.&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Since there are generally more possible objects than hash values, two objects
may hash to the same value. This is called a
&lt;a href="https://en.wikipedia.org/wiki/Hash_collision"&gt;hash collision&lt;/a&gt;, and anything
that deals with hashes should be able to deal with them.&lt;/p&gt;
&lt;p&gt;This won't be discussed here, but an additional property that a good hash
function should satisfy to be useful is this:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;The hash of an object should be cheap to compute.&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;What is it used for?&lt;/h2&gt;
&lt;p&gt;If we have a hash function that satisfies the above properties, then we can
use it to create from a collection of objects something called a &lt;em&gt;hash table&lt;/em&gt;.
Suppose we have a collection of objects, and given any object, we want to be
able to compute very quickly if that object belongs to our collection. We
could store these objects in an ordered array, but then to determine if it is
in the array, we would have to search potentially through every element of the
array (in other words, an \(O(n)\)) algorithm.&lt;/p&gt;
&lt;p&gt;With hashing, we can do better. We create what is known as a
&lt;a href="https://en.wikipedia.org/wiki/Hash_table"&gt;&lt;em&gt;hash table&lt;/em&gt;&lt;/a&gt;. Instead of storing
the objects in an ordered array, we create an array of buckets, each
corresponding to some hash values. We then hash each object, and store it into
the array corresponding to its hash value (if there are more hash values than
buckets, we distribute them using a second hash function, which can be as
simple as taking the modulus with respect to the number of buckets, &lt;code&gt;% n&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;This image from
&lt;a href="https://en.wikipedia.org/wiki/File:Hash_table_3_1_1_0_1_0_0_SP.svg"&gt;Wikipedia&lt;/a&gt;
shows an example.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://upload.wikimedia.org/wikipedia/commons/7/7d/Hash_table_3_1_1_0_1_0_0_SP.svg" alt="img"&gt;&lt;/p&gt;
&lt;p&gt;To determine if an object is in a hash table, we only have to hash the object,
and look in the bucket corresponding to that hash. This is an \(O(1)\)
algorithm, assuming we have a good hash function, because each bucket will
generally hold very few objects, possibly even none.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Note: there are some additional things that need to be done to handle hash
collisions, but the basic idea is the same, and as long as there aren't too
many hash collisions, which should happen if hash values are evenly
distributed and the size of the hash table is large compared to the number of
objects stored in it, the average time to determine if an object is in the
hash table is still \(O(1)\).&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;Hashing in Python&lt;/h2&gt;
&lt;p&gt;Python has a built in function that performs a hash called &lt;code&gt;hash()&lt;/code&gt;.  For many
objects, the hash is not very surprising.  Note, the hashes you see below may
not be the same ones you see if you run the examples, because Python hashing
depends on the architecture of the machine you are running on, and, in newer
versions of Python, hashes are randomized for security purposes.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; hash(10)
10
&amp;gt;&amp;gt;&amp;gt; hash(()) # An empty tuple
3527539
&amp;gt;&amp;gt;&amp;gt; hash('a')
12416037344
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In Python, not all objects are hashable. For example&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; hash([]) # An empty list
Traceback (most recent call last):
  File "&amp;lt;stdin&amp;gt;", line 1, in &amp;lt;module&amp;gt;
TypeError: unhashable type: 'list'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is because Python has an additional restriction on hashing:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;In order for an object to be hashable, it must be immutable.&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This is important basically because we want the hash of an object to remain
the same across the object's lifetime. But if we have a mutable object, then
that object itself can change over its lifetime. But then according to our
first bullet point above, that object's hash has to change too.&lt;/p&gt;
&lt;p&gt;This restriction simplifies hash tables. If we allowed an object's hash to
change while it is in a hash table, we would have to move it to a different
bucket. Not only is this costly, but the hash table would have to &lt;em&gt;notice&lt;/em&gt;
that this happened; the object itself doesn't know that it is sitting in a
hash table, at least not in the Python implementation.&lt;/p&gt;
&lt;p&gt;In Python, there are two objects that correspond to hash tables, &lt;code&gt;dict&lt;/code&gt; and
&lt;code&gt;set&lt;/code&gt;. A &lt;code&gt;dict&lt;/code&gt; is a special kind of hash table called an
&lt;a href="https://en.wikipedia.org/wiki/Associative_array"&gt;&lt;em&gt;associative array&lt;/em&gt;&lt;/a&gt;. An
associative array is a hash table where each element of the hash table points
to another object. The other object itself is not hashed.&lt;/p&gt;
&lt;p&gt;Think of an associative array as a generalization of a regular array (like a
&lt;code&gt;list&lt;/code&gt;). In a &lt;code&gt;list&lt;/code&gt;, objects are associated to nonnegative integer indices,
like&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; l = ['a', 'b', 7]
&amp;gt;&amp;gt; l[0]
'a'
&amp;gt;&amp;gt;&amp;gt; l[2]
7
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In an associative array (i.e., a &lt;code&gt;dict&lt;/code&gt;) we can index objects by anything, so
long as the key is hashable.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; d = {0: 'a', 'hello': ['world']}
&amp;gt;&amp;gt;&amp;gt; d[0]
'a'
&amp;gt;&amp;gt;&amp;gt; d['hello']
['world']
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that only the keys need to be hashable. The values can be anything, even
unhashable objects like lists.&lt;/p&gt;
&lt;p&gt;The uses for associative arrays are boundless. &lt;code&gt;dict&lt;/code&gt; is one of the most
useful data types in the Python language. Some example uses are&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Extension of &lt;code&gt;list&lt;/code&gt; with "missing values". For example, &lt;code&gt;{0: 'a', 2: 7}&lt;/code&gt;
would correspond to the above list &lt;code&gt;l&lt;/code&gt; with the value &lt;code&gt;'b'&lt;/code&gt; corresponding to
the key &lt;code&gt;1&lt;/code&gt; removed.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Representation of a mathematical function with a finite domain.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;A poor-man's database (the Wikipedia image above is an associative array
mapping names to telephone numbers).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Implementing a &lt;a href="https://stackoverflow.com/q/60208/161801"&gt;Pythonic version&lt;/a&gt;
of the switch-case statement.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The other type of hash table, &lt;code&gt;set&lt;/code&gt;, more closely matches the definition I
gave above for a hash table. A &lt;code&gt;set&lt;/code&gt; is just a container of hashable
objects. &lt;code&gt;set&lt;/code&gt;s are unordered, and can only contain one of each object (this
is why they are called "sets," because this matches the mathematical
definition of a &lt;a href="https://en.wikipedia.org/wiki/Set_(mathematics)"&gt;set&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;In Python 2.7 or later, you can create a set with &lt;code&gt;{&lt;/code&gt; and &lt;code&gt;}&lt;/code&gt;, like &lt;code&gt;{a, b, c}&lt;/code&gt;. Otherwise, use &lt;code&gt;set([a, b, c])&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; s = {0, (), '2'}
&amp;gt;&amp;gt;&amp;gt; s
{0, '2', ()}
&amp;gt;&amp;gt;&amp;gt; s.add(1)
&amp;gt;&amp;gt;&amp;gt; s
{0, 1, '2', ()}
&amp;gt;&amp;gt;&amp;gt; s.add(0)
&amp;gt;&amp;gt;&amp;gt; s
{0, 1, '2', ()}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A final note: &lt;code&gt;set&lt;/code&gt; and &lt;code&gt;dict&lt;/code&gt; are themselves mutable, and hence not hashable!
There is an immutable version of &lt;code&gt;set&lt;/code&gt; called &lt;code&gt;frozenset&lt;/code&gt;. There are no
immutable dictionaries.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; f = frozenset([0, (), '2'])
&amp;gt;&amp;gt;&amp;gt; f
frozenset({0, '2', ()})
&amp;gt;&amp;gt;&amp;gt; hash(f)
-7776452922777075760
&amp;gt;&amp;gt;&amp;gt; # A frozenset, unlike a set, can be used as a dictionary key
&amp;gt;&amp;gt;&amp;gt; d[f] = 'a set'
&amp;gt;&amp;gt;&amp;gt; d
{0: 'a', frozenset({0, '2', ()}): 'a set', 'hello': ['world']}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Creating your own hashable objects&lt;/h2&gt;
&lt;p&gt;Before we move on, there is one final thing we need to know about hashing in
Python, which is how to create hashes for custom objects. By default, if we
create an object, it will be hashable.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; class Nothing(object):
...     pass
...
&amp;gt;&amp;gt;&amp;gt; N = Nothing()
&amp;gt;&amp;gt;&amp;gt; hash(N)
270498113
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Implementation-wise, the hash is just the object's &lt;code&gt;id&lt;/code&gt;, which corresponds to
its position in memory. This satisfies the above conditions: it is (extremely)
cheap to compute, and since by default objects in Python compare unequal to
one another, objects with different hashes will be unequal.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; M = Nothing()
&amp;gt;&amp;gt;&amp;gt; M == N
False
&amp;gt;&amp;gt;&amp;gt; hash(M)
270498117
&amp;gt;&amp;gt;&amp;gt; hash(M) == hash(N)
False
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To define a hash function for an object, define the &lt;code&gt;__hash__&lt;/code&gt; method.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; class HashToOne(object):
...     def __hash__(self):
...         return 1
...
&amp;gt;&amp;gt;&amp;gt; HTO = HashToOne()
&amp;gt;&amp;gt;&amp;gt; hash(HTO)
1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To set an object as not hashable, set &lt;code&gt;__hash__&lt;/code&gt; to &lt;code&gt;None&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; class NotHashable(object):
...     __hash__ = None
...
&amp;gt;&amp;gt;&amp;gt; NH = NotHashable()
&amp;gt;&amp;gt;&amp;gt; hash(NH)
Traceback (most recent call last):
  File "&amp;lt;stdin&amp;gt;", line 1, in &amp;lt;module&amp;gt;
TypeError: unhashable type: 'NotHashable'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Finally, to override the equality operator &lt;code&gt;==&lt;/code&gt;, define &lt;code&gt;__eq__&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; class AlwaysEqual(object):
...     def __eq__(self, other):
...         if isinstance(other, AlwaysEqual):
...             return True
...        return False
...
&amp;gt;&amp;gt;&amp;gt; AE1 = AlwaysEqual()
&amp;gt;&amp;gt;&amp;gt; AE2 = AlwaysEqual()
&amp;gt;&amp;gt;&amp;gt; AE1 == AE2
True
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;One of the key points that I hope you will take away from this post is that if
you override &lt;code&gt;__eq__&lt;/code&gt;, you &lt;strong&gt;must&lt;/strong&gt; also override &lt;code&gt;__hash__&lt;/code&gt; to agree. Note
that Python 3 will actually require this: in Python 3, you cannot override
&lt;code&gt;__eq__&lt;/code&gt; and not override &lt;code&gt;__hash__&lt;/code&gt;. But that's as far as Python goes in
enforcing these rules, as we will see below. In particular, Python will never
actually check that your &lt;code&gt;__hash__&lt;/code&gt; actually agrees with your &lt;code&gt;__eq__&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;Messing with hashing&lt;/h2&gt;
&lt;p&gt;Now to the fun stuff. What happens if we break some of the invariants that
Python expects of hashing. Python expects two key invariants to hold&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;The hash of an object does not change across the object's lifetime (in
other words, a hashable object should be immutable).&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;a == b&lt;/code&gt; implies &lt;code&gt;hash(a) == hash(b)&lt;/code&gt; (note that the reverse might not
hold in the case of a hash collision).&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;As we shall see, Python expects, but does not enforce either of these.&lt;/p&gt;
&lt;h3&gt;Example 1: Mutating a hash&lt;/h3&gt;
&lt;p&gt;Let's break rule 1 first. Let's create an object with a hash, and then change
that object's hash over its lifetime, and see what sorts of things can happen.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; class Bad(object):
...     def __init__(self, hash): # The object's hash will be hash
...         self.hash = hash
...     def __hash__(self):
...         return self.hash
...
&amp;gt;&amp;gt;&amp;gt; b = Bad(1)
&amp;gt;&amp;gt;&amp;gt; hash(b)
1
&amp;gt;&amp;gt;&amp;gt; d = {b:42}
&amp;gt;&amp;gt;&amp;gt; d[b]
42
&amp;gt;&amp;gt;&amp;gt; b.hash = 2
&amp;gt;&amp;gt;&amp;gt; hash(b)
2
&amp;gt;&amp;gt;&amp;gt; d[b]
Traceback (most recent call last):
  File "&amp;lt;stdin&amp;gt;", line 1, in &amp;lt;module&amp;gt;
KeyError: &amp;lt;__main__.Bad object at 0x1047e7438&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here, we implicitly changed the hash of &lt;code&gt;b&lt;/code&gt; by mutating the attribute of &lt;code&gt;b&lt;/code&gt;
that is used to compute the hash. As a result, the object is no longer found
in a dictionary, which uses the hash to find the object.&lt;/p&gt;
&lt;p&gt;The object is still there, we just can't access it any more.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; d
{&amp;lt;__main__.Bad object at 0x1047e7438&amp;gt;: 42}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that Python doesn't prevent me from doing this. We could make it if we
want (e.g., by making &lt;code&gt;__setattr__&lt;/code&gt; raise &lt;code&gt;AttributeError&lt;/code&gt;), but even then we
could forcibly change it by modifying the object's &lt;code&gt;__dict__&lt;/code&gt;. We could try
some more fancy things using descriptors, metaclasses, and/or
&lt;code&gt;__getattribute__&lt;/code&gt;, but even then, if we knew what was happening, we could
probably find a way to change it.&lt;/p&gt;
&lt;p&gt;This is what is meant when people say that Python is a "consenting adults"
language. You are expected to not try to break things, but generally aren't
prevented from doing so if you try.&lt;/p&gt;
&lt;h3&gt;Example 2: More mutation&lt;/h3&gt;
&lt;p&gt;Let's try something even more crazy. Let's make an object that hashes to a
different value each time we look at the hash.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; class DifferentHash(object):
...     def __init__(self):
...         self.hashcounter = 0
...     def __hash__(self):
...         self.hashcounter += 1
...         return self.hashcounter
...
&amp;gt;&amp;gt;&amp;gt; DH = DifferentHash()
&amp;gt;&amp;gt;&amp;gt; hash(DH)
1
&amp;gt;&amp;gt;&amp;gt; hash(DH)
2
&amp;gt;&amp;gt;&amp;gt; hash(DH)
3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Obviously, if we use &lt;code&gt;DH&lt;/code&gt; as a key to a dictionary, then it will not work,
because we will run into the same issue we had with &lt;code&gt;Bad&lt;/code&gt;. But what about
putting &lt;code&gt;DH&lt;/code&gt; in a &lt;code&gt;set&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; DHset = {DH, DH, DH}
&amp;gt;&amp;gt;&amp;gt; DHset
{&amp;lt;__main__.DifferentHash at 0x101f79f50&amp;gt;,
 &amp;lt;__main__.DifferentHash at 0x101f79f50&amp;gt;,
 &amp;lt;__main__.DifferentHash at 0x101f79f50&amp;gt;}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Woah! We put the exact same object in a &lt;code&gt;set&lt;/code&gt; three times, and it appeared all
three times. This is not what is supposed to happen with a set.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; {1, 1, 1}
{1}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;What happens when we do stuff with &lt;code&gt;DHset&lt;/code&gt;?&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; DHset.remove(DH)
Traceback (most recent call last):
  File "&amp;lt;stdin&amp;gt;", line 1, in &amp;lt;module&amp;gt;
KeyError: &amp;lt;__main__.DifferentHash object at 0x1047e75f8&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That didn't work, because &lt;code&gt;set.remove&lt;/code&gt; searches for an object by its hash,
which is different by this point.&lt;/p&gt;
&lt;p&gt;Now let's make a copy of &lt;code&gt;DHset&lt;/code&gt;. The &lt;code&gt;set.copy&lt;/code&gt; method will create a shallow
copy (meaning that the set container itself will be different, according to
&lt;code&gt;is&lt;/code&gt; comparison, but the objects themselves will the same, according to &lt;code&gt;is&lt;/code&gt;
comparison).&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; DHset2 = DHset.copy()
&amp;gt;&amp;gt;&amp;gt; DHset2 == DHset
True
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Everything is fine so far. This object is only going to cause trouble if
something recomputes its hash. But remember that the whole reason that we had
trouble with something like &lt;code&gt;Bad&lt;/code&gt; above is that Python &lt;em&gt;doesn't&lt;/em&gt; recompute
that hash of an object, unless it has to. So let's do something that will
force it to do so: let's pop an object from one of the sets and add it back
in.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; D = DHset.pop()
&amp;gt;&amp;gt;&amp;gt; DHset.add(D)
&amp;gt;&amp;gt;&amp;gt; DHset
{&amp;lt;__main__.DifferentHash at 0x101f79f50&amp;gt;,
 &amp;lt;__main__.DifferentHash at 0x101f79f50&amp;gt;,
 &amp;lt;__main__.DifferentHash at 0x101f79f50&amp;gt;}
&amp;gt;&amp;gt;&amp;gt; DHset2
{&amp;lt;__main__.DifferentHash at 0x101f79f50&amp;gt;,
 &amp;lt;__main__.DifferentHash at 0x101f79f50&amp;gt;,
 &amp;lt;__main__.DifferentHash at 0x101f79f50&amp;gt;}
&amp;gt;&amp;gt;&amp;gt; DHset == DHset2
False
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There we go. By removing it from the set, we made the set forget about its
hash, so it had to be recomputed when we added it again. This version of
&lt;code&gt;DHset&lt;/code&gt; now has a &lt;code&gt;DH&lt;/code&gt; with a different hash than it had before. Thinking back
to &lt;code&gt;set&lt;/code&gt; being a hash table, in this &lt;code&gt;DHset&lt;/code&gt;, the three &lt;code&gt;DH&lt;/code&gt; objects are in
different "buckets" than they were in before. &lt;code&gt;DHset.__eq__(DHset2)&lt;/code&gt; notices
that the bucket structure is different right away and returns &lt;code&gt;False&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;By the way, what hash value are we up to these days?&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; hash(DH)
9
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Example 3: When &lt;code&gt;a == b&lt;/code&gt; does not imply &lt;code&gt;hash(a) == hash(b)&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;Now let's look at point 2. What happens if we create an object with &lt;code&gt;__eq__&lt;/code&gt;
that disagrees with &lt;code&gt;__hash__&lt;/code&gt;. We actually already have made a class like
this, the &lt;code&gt;AlwaysEqual&lt;/code&gt; object above. Instances of &lt;code&gt;AlwaysEqual&lt;/code&gt; will always
compare equal to one another, but they will not have the same hash, because
they will use &lt;code&gt;object&lt;/code&gt;'s default &lt;code&gt;__hash__&lt;/code&gt; of &lt;code&gt;id&lt;/code&gt;. Let's take a closer look
at the &lt;code&gt;AE1&lt;/code&gt; and &lt;code&gt;AE2&lt;/code&gt; objects we created above.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; hash(AE1)
270498221
&amp;gt;&amp;gt;&amp;gt; hash(AE2)
270498197
&amp;gt;&amp;gt;&amp;gt; hash(AE1) == hash(AE2)
False
&amp;gt;&amp;gt;&amp;gt; AE1 == AE2
True
&amp;gt;&amp;gt;&amp;gt; {AE1, AE2}
{&amp;lt;__main__.AlwaysEqual at 0x101f79950&amp;gt;,
 &amp;lt;__main__.AlwaysEqual at 0x101f79ad0&amp;gt;}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can already see that we have broken one of the key properties of a &lt;code&gt;set&lt;/code&gt;,
which is that it does not contain the same object twice (remember that &lt;code&gt;AE1&lt;/code&gt;
and &lt;code&gt;AE2&lt;/code&gt; should be considered the "same object" because &lt;code&gt;AE1 == AE2&lt;/code&gt; is
&lt;code&gt;True&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;This can lead to subtle issues. For example, suppose we had a list and we
wanted to remove all the duplicate items from it. An easy way to do this is to
convert the list to a set and then convert it back to a list.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; l = ['a', 'a', 'c', 'a', 'c', 'b']
&amp;gt;&amp;gt;&amp;gt; list(set(l))
['a', 'c', 'b']
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, this method is obviously not going to work for a list of &lt;code&gt;AlwaysEqual&lt;/code&gt; objects.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; AE3 = AlwaysEqual()
&amp;gt;&amp;gt;&amp;gt; l = [AE1, AE1, AE3, AE2, AE3]
&amp;gt;&amp;gt;&amp;gt; list(set(l))
[&amp;lt;__main__.AlwaysEqual at 0x102c1d590&amp;gt;,
 &amp;lt;__main__.AlwaysEqual at 0x101f79ad0&amp;gt;,
 &amp;lt;__main__.AlwaysEqual at 0x101f79950&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Actually, what happened here is that the equality that we defined on
&lt;code&gt;AlwaysEqual&lt;/code&gt; was essentially ignored. We got a list of unique items by &lt;code&gt;id&lt;/code&gt;,
instead of by &lt;code&gt;__eq__&lt;/code&gt;. You can imagine that if &lt;code&gt;__eq__&lt;/code&gt; were something a
little less trivial, where some, but not all, objects are considered equal,
that this could lead to very subtle issues.&lt;/p&gt;
&lt;p&gt;But there is an issue with the above algorithm. It isn't stable, that is, it
removes the ordering that we had on the list. We could do this better by
making a new list, and looping through the old one, adding elements to the new
list if they aren't already there.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; def uniq(l):
...     newl = []
...     for i in l:
...         if i not in newl:
...             newl.append(i)
...     return newl
...
&amp;gt;&amp;gt;&amp;gt; uniq(['a', 'a', 'c', 'a', 'c', 'b'])
['a', 'c', 'b']
&amp;gt;&amp;gt;&amp;gt; uniq([AE1, AE1, AE3, AE2, AE3])
[&amp;lt;__main__.AlwaysEqual at 0x101f79ad0&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This time, we used &lt;code&gt;in&lt;/code&gt;, which uses &lt;code&gt;==&lt;/code&gt;, so we got only one unique element of
the list of &lt;code&gt;AlwaysEqual&lt;/code&gt; objects.&lt;/p&gt;
&lt;p&gt;But there is an issue with this algorithm as well. Checking if something is in
a list is \(O(n)\), but we have an object that allows checking in \(O(1)\)
time, namely, a &lt;code&gt;set&lt;/code&gt;. So a more efficient version might be to create a set
alongside the new list for containment checking purposes.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; def uniq2(l):
...     newl = []
...     newlset = set()
...     for i in l:
...         if i not in newlset:
...             newl.append(i)
...             newlset.add(i)
...     return newl
...
&amp;gt;&amp;gt;&amp;gt; uniq2(['a', 'a', 'c', 'a', 'c', 'b'])
['a', 'c', 'b']
&amp;gt;&amp;gt;&amp;gt; uniq2([AE1, AE1, AE3, AE2, AE3])
[&amp;lt;__main__.AlwaysEqual at 0x101f79ad0&amp;gt;,
 &amp;lt;__main__.AlwaysEqual at 0x102c1d590&amp;gt;,
 &amp;lt;__main__.AlwaysEqual at 0x101f79950&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Bah! Since we used a set, we compared by hashing, not equality, so we are left
with three objects again. Notice the extremely subtle difference
here. Basically, it is this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; AE1 in {AE2}
False
&amp;gt;&amp;gt;&amp;gt; AE1 in [AE2]
True
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Set containment uses hashing; list containment uses equality. If the two don't
agree, then the result of your algorithm will depend on which one you use!&lt;/p&gt;
&lt;p&gt;By the way, as you might expect, dictionary containment also uses hashing, and
tuple containment uses equality:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; AE1 in {AE2: 42}
False
&amp;gt;&amp;gt;&amp;gt; AE1 in (AE2,)
True
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Example 4: Caching hashing&lt;/h3&gt;
&lt;p&gt;If you ever want to add subtle bizarreness to a system, add some sort of
caching, and then do it wrong.&lt;/p&gt;
&lt;p&gt;As we noted in the beginning, one important property of a hash function is
that it is quick to compute. A nice way to achieve this for heavily cached
objects is to cache the value of the cache on the object, so that it only
needs to be computed once. The pattern (which is modeled after SymPy's
&lt;code&gt;Basic&lt;/code&gt;) is something like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; class HashCache(object):
...     def __init__(self, arg):
...         self.arg = arg
...         self.hash_cache = None
...     def __hash__(self):
...         if self.hash_cache is None:
...             self.hash_cache = hash(self.arg)
...         return self.hash_cache
...     def __eq__(self, other):
...         if not isinstance(other, HashCache):
...             return False
...         return self.arg == other.arg
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;HashCache&lt;/code&gt; is nothing more than a small wrapper around a hashable argument,
which caches its hash.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; hash('a')
12416037344
&amp;gt;&amp;gt;&amp;gt; a = HashCache('a')
&amp;gt;&amp;gt;&amp;gt; hash(a)
12416037344
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For ordinary Python builtins, simply recomputing the hash will be faster than
the attribute lookup used by &lt;code&gt;HashCache&lt;/code&gt;. &lt;em&gt;Note: This uses the &lt;code&gt;%timeit&lt;/code&gt; magic
from IPython. &lt;code&gt;%timeit&lt;/code&gt; only works when run in IPython or Jupyter.&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; %timeit hash('a')
10000000 loops, best of 3: 69.9 ns per loop
&amp;gt;&amp;gt;&amp;gt; %timeit hash(a)
1000000 loops, best of 3: 328 ns per loop
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But for a custom object, computing the hash may be more computationally
expensive. As hashing is supposed to agree with equality (as I hope you've
realized by now!), if computing equality is expensive, computing a hash
function that agrees with it might be expensive as well.&lt;/p&gt;
&lt;p&gt;As a simple example of where this might be useful, consider a highly nested
tuple, an object whose hash that is relatively expensive to compute.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; a = ()
&amp;gt;&amp;gt;&amp;gt; for i in range(1000):
...     a = (a,)
...
&amp;gt;&amp;gt;&amp;gt; A = HashCache(a)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; %timeit hash(a)
100000 loops, best of 3: 9.61 µs per loop
&amp;gt;&amp;gt;&amp;gt; %timeit hash(A)
1000000 loops, best of 3: 325 ns per loop
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So far, we haven't done anything wrong. &lt;code&gt;HashCache&lt;/code&gt;, as you may have noticed,
has &lt;code&gt;__eq__&lt;/code&gt; defined correctly:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; HashCache(1) == HashCache(2)
False
&amp;gt;&amp;gt;&amp;gt; HashCache(1) == HashCache(1)
True
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But what happens if we mutate a &lt;code&gt;HashCache&lt;/code&gt;. This is different from examples 1
and 2 above, because we will be mutating what happens with equality testing,
but not the hash (because of the cache).&lt;/p&gt;
&lt;p&gt;&lt;em&gt;In the below example, recall that small integers hash to themselves, so
&lt;code&gt;hash(1) == 1&lt;/code&gt; and &lt;code&gt;hash(2) == 2&lt;/code&gt;.&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; a = HashCache(1)
&amp;gt;&amp;gt;&amp;gt; d = {a: 42}
&amp;gt;&amp;gt;&amp;gt; a.arg = 2
&amp;gt;&amp;gt;&amp;gt; hash(a)
1
&amp;gt;&amp;gt;&amp;gt; d[a]
42
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Because we cached the hash of &lt;code&gt;a&lt;/code&gt;, which was computed as soon as we created
the dictionary &lt;code&gt;d&lt;/code&gt;, it remained unchanged when modified the arg to be
&lt;code&gt;2&lt;/code&gt;. Thus, we can still find the key of the dictionary. But since we have
mutated &lt;code&gt;a&lt;/code&gt;, the equality testing on it has changed. This means that, as with
the previous example, we are going to have issues with dicts and sets keeping
unique keys and entries (respectively).&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; a = HashCache(1)
&amp;gt;&amp;gt;&amp;gt; b = HashCache(2)
&amp;gt;&amp;gt;&amp;gt; hash(a)
1
&amp;gt;&amp;gt;&amp;gt; hash(b)
2
&amp;gt;&amp;gt;&amp;gt; b.arg = 1
&amp;gt;&amp;gt;&amp;gt; a == b
True
&amp;gt;&amp;gt;&amp;gt; hash(a) == hash(b)
False
&amp;gt;&amp;gt;&amp;gt; {a, b}
{&amp;lt;__main__.HashCache at 0x102c32050&amp;gt;, &amp;lt;__main__.HashCache at 0x102c32450&amp;gt;}
&amp;gt;&amp;gt;&amp;gt; uniq([a, b])
[&amp;lt;__main__.HashCache at 0x102c32050&amp;gt;]
&amp;gt;&amp;gt;&amp;gt; uniq2([a, b])
[&amp;lt;__main__.HashCache at 0x102c32050&amp;gt;, &amp;lt;__main__.HashCache at 0x102c32450&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Once we mutate &lt;code&gt;b&lt;/code&gt; so that it compares equal to &lt;code&gt;a&lt;/code&gt;, we start to have the same sort of issues that we had in example 3 with &lt;code&gt;AlwaysEqual&lt;/code&gt;. Let's look at an instant replay.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; a = HashCache(1)
&amp;gt;&amp;gt;&amp;gt; b = HashCache(2)
&amp;gt;&amp;gt;&amp;gt; b.arg = 1
&amp;gt;&amp;gt;&amp;gt; print(a == b)
True
&amp;gt;&amp;gt;&amp;gt; print(hash(a) == hash(b))
True
&amp;gt;&amp;gt;&amp;gt; print({a, b})
set([&amp;lt;__main__.HashCache object at 0x102c32a10&amp;gt;])
&amp;gt;&amp;gt;&amp;gt; print(uniq([a, b]))
[&amp;lt;__main__.HashCache object at 0x102c32a50&amp;gt;]
&amp;gt;&amp;gt;&amp;gt; print(uniq2([a, b]))
[&amp;lt;__main__.HashCache object at 0x102c32a50&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Wait a minute, this time it's different! Comparing it to above, it's pretty
easy to see what was different this time. We left out the part where we showed
the hash of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;. When we did that the first time, it cached the hash
of &lt;code&gt;b&lt;/code&gt;, making it forever be &lt;code&gt;2&lt;/code&gt;, but when we didn't do it the second time,
the hash had not been cached yet, so the first time it is computed (in the
&lt;code&gt;print(hash(a) == hash(b))&lt;/code&gt; line), &lt;code&gt;b.arg&lt;/code&gt; has already been changed to &lt;code&gt;1&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;And herein lies the extreme subtlety: if you mutate an object with that hashes
its cache like this, you will run into issues &lt;strong&gt;only if&lt;/strong&gt; you had already
called some function that hashed the object somewhere. Now just about anything
might compute the hash of an object. Or it might not. For example, our &lt;code&gt;uniq2&lt;/code&gt;
function computes the hash of the objects in its input list, because it stores
them in a set, but &lt;code&gt;uniq&lt;/code&gt; does not:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; a = HashCache(1)
&amp;gt;&amp;gt;&amp;gt; b = HashCache(2)
&amp;gt;&amp;gt;&amp;gt; uniq2([a, b])
&amp;gt;&amp;gt;&amp;gt; b.arg = 1
&amp;gt;&amp;gt;&amp;gt; print(a == b)
True
&amp;gt;&amp;gt;&amp;gt; print(hash(a) == hash(b))
False
&amp;gt;&amp;gt;&amp;gt; print({a, b})
set([&amp;lt;__main__.HashCache object at 0x102c32c50&amp;gt;, &amp;lt;__main__.HashCache object at 0x102c32c10&amp;gt;])
&amp;gt;&amp;gt;&amp;gt; print(uniq([a, b]))
[&amp;lt;__main__.HashCache object at 0x102c32c50&amp;gt;]
&amp;gt;&amp;gt;&amp;gt; print(uniq2([a, b]))
[&amp;lt;__main__.HashCache object at 0x102c32c50&amp;gt;, &amp;lt;__main__.HashCache object at 0x102c32c10&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; a = HashCache(1)
&amp;gt;&amp;gt;&amp;gt; b = HashCache(2)
&amp;gt;&amp;gt;&amp;gt; uniq([a, b])
&amp;gt;&amp;gt;&amp;gt; b.arg = 1
&amp;gt;&amp;gt;&amp;gt; print(a == b)
True
&amp;gt;&amp;gt;&amp;gt; print(hash(a) == hash(b))
True
&amp;gt;&amp;gt;&amp;gt; print({a, b})
set([&amp;lt;__main__.HashCache object at 0x102c32c90&amp;gt;])
&amp;gt;&amp;gt;&amp;gt; print(uniq([a, b]))
[&amp;lt;__main__.HashCache object at 0x102c32bd0&amp;gt;]
&amp;gt;&amp;gt;&amp;gt; print(uniq2([a, b]))
[&amp;lt;__main__.HashCache object at 0x102c32bd0&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The moral of this final example is that if you are going to cache something,
that something had better be immutable.&lt;/p&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;The conclusion is this: don't mess with hashing. The two invariants above are
important. Let's restate them here,&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;The hash of an object must not change across the object's lifetime (in
other words, a hashable object should be immutable).&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;a == b&lt;/code&gt; implies &lt;code&gt;hash(a) == hash(b)&lt;/code&gt; (note that the reverse might not
hold in the case of a hash collision).&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;If you don't follow these rules, you will run into very subtle issues, because
very basic Python operations expect these invariants.&lt;/p&gt;
&lt;p&gt;If you want to be able to mutate an object's properties, you have two
options. First, make the object unhashable (set &lt;code&gt;__hash__ = None&lt;/code&gt;). You won't
be able to use it in sets or as keys to a dictionary, but you will be free to
change the object in-place however you want.&lt;/p&gt;
&lt;p&gt;A second option is to make all mutable properties non-dependent on hashing or
equality testing. This option works well if you just want to cache some
internal state that doesn't inherently change the object. Both &lt;code&gt;__eq__&lt;/code&gt; and
&lt;code&gt;__hash__&lt;/code&gt; should remain unchanged by changes to this state. You may also want
to make sure you use proper getters and setters to prevent modification of
internal state that equality testing and hashing does depend on.&lt;/p&gt;
&lt;p&gt;If you choose this second option, however, be aware that Python considers it
fair game to swap out two identical immutable (i.e., hashable) objects at any
time. If &lt;code&gt;a == b&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; is hashable, Python (and Python libraries) are free
to replace &lt;code&gt;a&lt;/code&gt; with &lt;code&gt;b&lt;/code&gt; anywhere. For example, Python uses an optimization on
strings called &lt;em&gt;interning&lt;/em&gt;, where common strings are stored only once in
memory. A similar optimization is used in CPython for small integers. If store
something on &lt;code&gt;a&lt;/code&gt; but not &lt;code&gt;b&lt;/code&gt; and make &lt;code&gt;a&lt;/code&gt;'s hash ignore that data, you may
find that some function that should return &lt;code&gt;a&lt;/code&gt; may actually return &lt;code&gt;b&lt;/code&gt;. For
this reason, I generally don't recommend this second option unless you know
what you are doing.&lt;/p&gt;
&lt;p&gt;Finally, to keep invariant 2, here are some tips:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Make sure that the parts of the object that you use to compare equality are
not themselves mutable. If they are, then your object cannot itself be
immutable. This means that if &lt;code&gt;a == b&lt;/code&gt; depends on &lt;code&gt;a.attr == b.attr&lt;/code&gt;, and
&lt;code&gt;a.attr&lt;/code&gt; is a list, then you will need to use a tuple instead (if you want
&lt;code&gt;a&lt;/code&gt; to be hashable).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;You don't have to invent a hash function. If you find yourself doing
bitshifts and XORs, you're doing it wrong. Reuse Python's builtin hashable
objects. If the hash of your object should depend on the hash of &lt;code&gt;a&lt;/code&gt; and
&lt;code&gt;b&lt;/code&gt;, define &lt;code&gt;__hash__&lt;/code&gt; to return &lt;code&gt;hash((a, b))&lt;/code&gt;. If the order of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;
does not matter, use &lt;code&gt;hash(frozenset([a, b]))&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Don't cache something unless you know that the entire cached state will not
be changed over the lifetime of the cache. Hashable objects are actually
great for caches. If they properly satisfy invariant 1, and all the state
that should be cached is part of the hash, then you will not need to
worry. And the best part is that you can just use &lt;code&gt;dict&lt;/code&gt; for your cache.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Unless you really need the performance or memory gains, don't make your
objects mutable. This makes programs much harder to reason about. Some
functional programming languages take this idea so far that they don't allow
any mutable objects.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Don't worry about the situation where &lt;code&gt;hash(a) == hash(b)&lt;/code&gt; but &lt;code&gt;a != b&lt;/code&gt;. This is a hash collision. Unlike the issues we looked at here, hash
collisions are expected and checked for in Python. For example, our
&lt;code&gt;HashToOne&lt;/code&gt; object from the beginning will always hash to 1, but different
instances will compare unequal. We can see that the right thing is done in
every case with them.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; a = HashToOne()
&amp;gt;&amp;gt;&amp;gt; b = HashToOne()
&amp;gt;&amp;gt;&amp;gt; a == b
False
&amp;gt;&amp;gt;&amp;gt; hash(a) == hash(b)
True
&amp;gt;&amp;gt;&amp;gt; {a, b}
{&amp;lt;__main__.HashToOne at 0x102c32a10&amp;gt;, &amp;lt;__main__.HashToOne at 0x102c32cd0&amp;gt;}
&amp;gt;&amp;gt;&amp;gt; uniq([a, b])
[&amp;lt;__main__.HashToOne at 0x102c32cd0&amp;gt;, &amp;lt;__main__.HashToOne at 0x102c32a10&amp;gt;]
&amp;gt;&amp;gt;&amp;gt; uniq2([a, b])
[&amp;lt;__main__.HashToOne at 0x102c32cd0&amp;gt;, &amp;lt;__main__.HashToOne at 0x102c32a10&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The only concern with hash collisions is that too many of them can remove
the performance gains of &lt;code&gt;dict&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Conversely, if you are writing something that uses an object's hash, remember
that hash collisions are possible and unavoidable.&lt;/p&gt;
&lt;p&gt;A classic example of a hash collision is &lt;code&gt;-1&lt;/code&gt; and &lt;code&gt;-2&lt;/code&gt;. Remember I
mentioned above that small integers hash to themselves:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; hash(1)
1
&amp;gt;&amp;gt;&amp;gt; hash(-3)
-3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The exception to this is &lt;code&gt;-1&lt;/code&gt;. The CPython interpreter uses &lt;code&gt;-1&lt;/code&gt; as an error
state, so -1 is not a valid hash value. Hence, &lt;code&gt;hash(-1)&lt;/code&gt; can't be &lt;code&gt;-1&lt;/code&gt;. So
the Python developers picked the next closest thing.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; hash(-1)
-2
&amp;gt;&amp;gt;&amp;gt; hash(-2)
-2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you want to check if something handles hash collisions correctly, this is
a simple example.  I should also note that the fact that integers hash to
themselves is an implementation detail of CPython that may not be true in
alternate Python implementations.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Finally, we didn't discuss this much here, but don't assume that the hash of
your object will be the same across Python sessions. In Python 3.3 and up,
hash values of strings are randomized from a value that is seeded when
Python starts up. This also affects any object whose hash is computed
from the hash of strings. In Python 2.7, you can enable hash randomization
with the &lt;code&gt;-R&lt;/code&gt; flag to the interpreter. The following are two different
Python sessions.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; print(hash('a'))
-7750608935454338104
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; print(hash('a'))
8897161376854729812
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</description><category>mathjax</category><guid>https://asmeurer.github.io/blog/posts/what-happens-when-you-mess-with-hashing-in-python/</guid><pubDate>Tue, 26 Jan 2016 04:13:53 GMT</pubDate></item><item><title>"Doing Math with Python" by Amit Saha: Book Review</title><link>https://asmeurer.github.io/blog/posts/doing-math-with-python-by-amit-saha-book-review/</link><dc:creator>Aaron Meurer</dc:creator><description>&lt;div&gt;&lt;p&gt;&lt;em&gt;Note: No Starch Press has sent me a copy of this book for review purposes.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SHORT VERSION: &lt;em&gt;Doing Math with Python&lt;/em&gt; is well written and introduces
topics in a nice, mathematical way. I would recommend it for new users of
SymPy.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.nostarch.com/doingmathwithpython"&gt;&lt;em&gt;Doing Math with Python&lt;/em&gt;&lt;/a&gt; by
Amit Saha is a new book published by No Starch Press. The book shows how to
use Python to do high school-level mathematics. It makes heavy use of SymPy in
many chapters, and this review will focus mainly on those parts, as that is
the area I have expertise in.&lt;/p&gt;
&lt;p&gt;The book assumes a basic understanding of programming in Python 3, as well as
the mathematics used (although advanced topics are explained). No prior
background in the libraries used, SymPy and matplotlib, is assumed. For this
reason, this book can serve as an introduction them. Each chapter ends with
some programming exercises, which range from easy exercises to more advanced
ones.&lt;/p&gt;
&lt;p&gt;The book has seven chapters. In the first chapter, "Working with numbers",
basic mathematics using pure Python is introduced (no SymPy yet). It should be
noted that Python 3 (not Python 2) is required for this book. One of the
earliest examples in the book (&lt;code&gt;3/2 == 1.5&lt;/code&gt;) will not work correctly without
it. I applaud this choice, although I might have added a more prominent
warning to wary users. (As a side note, in the appendix, it is recommended to
install Python via &lt;a href="https://www.continuum.io/downloads"&gt;Anaconda&lt;/a&gt;, which I
also applaud). This chapter also introduces the &lt;code&gt;fractions&lt;/code&gt; module, which
seems odd since &lt;code&gt;sympy.Rational&lt;/code&gt; will be implicitly used for rational numbers
later in the text (to little harm, however, since SymPy automatically converts
&lt;code&gt;fractions.Fraction&lt;/code&gt; instances to &lt;code&gt;sympy.Rational&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;In all, this chapter is a good introduction to the basics of the mathematics
of Python. There is also an introduction to variables and strings. However, as
I noted above, one should really have some background with basic Python before
reading this book, as concepts like flow control and function definition are
assumed (note: there is an appendix that goes over this).&lt;/p&gt;
&lt;p&gt;Chapters 2 and 3 cover plotting with matplotlib and basic statistics,
respectively. I will not say much about the matplotlib chapter, since I know
only basic matplotlib myself. I will note that the chapter covers matplotlib
from a (high school) mathematics point of view, starting with a definition of
the Cartesian plane, which seems a fitting choice for the book.&lt;/p&gt;
&lt;p&gt;Chapter 3 shows how to do basic statistics (mean, median, standard deviation,
etc.) using pure Python. This chapter is clearly meant for pedagogical
purposes for basic statistics, since the basic functions &lt;code&gt;mean&lt;/code&gt;, &lt;code&gt;median&lt;/code&gt;,
etc. are implemented from scratch (as opposed to using &lt;code&gt;numpy.mean&lt;/code&gt; or the
standard library &lt;code&gt;statistics.mean&lt;/code&gt;). This serves as a good introduction to
more Python concepts (like &lt;code&gt;collections.Counter&lt;/code&gt;) and statistics.&lt;/p&gt;
&lt;p&gt;Note that the functions in this chapter assume that the data is the entire
population, not a sample. This is mentioned at the beginning of the chapter,
but not elaborated on. For example, this leads to a different definition of
variance than what might be seen elsewhere (the &lt;code&gt;calculate_variance&lt;/code&gt; used in
this chapter is &lt;code&gt;statistics.pvariance&lt;/code&gt;, not &lt;code&gt;statistics.variance&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;It is good to see that a numerically stable definition of variance is used
here (see &lt;a href="https://www.python.org/dev/peps/pep-0450/"&gt;PEP 450&lt;/a&gt; for more
discussion on this). These numerical issues show why it is important to use a
real statistics library rather than a home grown one. In other words, use this
chapter to learn more about statistics and Python, but if you ever need to do
statistics on real data, use a statistics library like &lt;code&gt;statistics&lt;/code&gt; or
&lt;code&gt;numpy&lt;/code&gt;. Finally, I should note that this book appears to be written against
Python 3.3, whereas &lt;code&gt;statistics&lt;/code&gt; was added to the Python standard library in
Python 3.4. Perhaps it will get a mention in future editions.&lt;/p&gt;
&lt;p&gt;Chapter 4, "Algebra and Symbolic Math with SymPy" starts the introduction to
SymPy. The chapter starts similar to the
&lt;a href="http://docs.sympy.org/latest/tutorial/index.html"&gt;official SymPy tutorial&lt;/a&gt; in
describing what symbolics is, and guiding the reader away from common
misconceptions and gotchas. The chapter does a good job of explaining common
gotchas and avoiding antipatterns.&lt;/p&gt;
&lt;p&gt;This chapter may serve as an alternative to the official tutorial. Unlike the
official tutorial, which jumps into
&lt;a href="http://docs.sympy.org/latest/tutorial/simplification.html#powers"&gt;higher-level mathematics&lt;/a&gt;
and &lt;a href="http://docs.sympy.org/latest/tutorial/matrices.html"&gt;broader use-cases&lt;/a&gt;,
this chapter may be better suited to those wishing to use SymPy from the
standpoint of high school mathematics.&lt;/p&gt;
&lt;p&gt;My only gripes with this chapter, which, in total, are minor, relate to printing.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The typesetting of the pretty printing is inconsistent and, in some cases,
incorrect. Powers are printed in the book using superscript numbers, like&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;x²
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;However, SymPy prints powers like&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; 2
x
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;even when Unicode pretty printing is enabled. This is a minor point, but it
may confuse users. Also, the output appears to use ASCII pretty printing
(mixed with superscript powers), for example&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    x²   x³   x⁴   x⁵
x + -- + -- + -- + --
    2    3    4    5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Most users will either get MathJax printing (if they are using the Jupyter
notebook), or Unicode printing, like&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;     2    3    4    5
    x    x    x    x
x + ── + ── + ── + ──
    2    3    4    5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Again, this is a minor point, but at the very least the correct printing
looks better than the fake printing used here.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;In line with the previous point, I would recommend telling the user to
start with &lt;code&gt;init_printing()&lt;/code&gt;. The function is used once to change the order
of printing to rev-lex (for series printing). There is a link to the
&lt;a href="http://docs.sympy.org/latest/tutorial/printing.html"&gt;tutorial page on printing&lt;/a&gt;. That
page goes into more depth than is necessary for the book, but I would
recommend at least mentioning to always call &lt;code&gt;init_printing()&lt;/code&gt;, as 2-D
printing can make a huge difference over the default &lt;code&gt;str&lt;/code&gt; printing, and it
obviates the need to call &lt;code&gt;pprint&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Chapter 5, "Playing with Sets and Probability" covers SymPy's set objects
(particularly &lt;code&gt;FiniteSet&lt;/code&gt;) to do some basic set theory and probability. I'm
excited to see this in the book. The sets module in SymPy is relatively new,
but quite powerful. We do not yet have an introduction to the sets module in
the SymPy tutorial. This chapter serves as a good introduction to it (albeit
only with finite sets, but the SymPy functions that operate on infinite sets
are exactly the same as the ones that operate on finite sets). In all, I don't
have much to say about this chapter other than that I was pleasantly surprised
to see it included.&lt;/p&gt;
&lt;p&gt;Chapter 6 shows how to draw geometric shapes and fractals with matplotlib. I
again won't say much on this, as I am no matplotlib expert. The ability to
draw leaf fractals and Sierpiński triangles with Python does look
entertaining, and should keep readers enthralled.&lt;/p&gt;
&lt;p&gt;Chapter 7, "Solving Calculus Problems" goes into more depth with SymPy. In
particular, assumptions, limits, derivatives, and integrals.  The chapter
alternates between symbolic formulations using SymPy and numeric
calculations (using &lt;code&gt;evalf&lt;/code&gt;). The numeric calculations are done both for
simple examples and more advanced things (like implementing gradient descent).&lt;/p&gt;
&lt;p&gt;One small gripe here. The book shows that&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from sympy import Symbol
x = Symbol('x')
if (x + 5) &amp;gt; 0:
    print('Do Something')
else:
    print('Do Something else')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;raises &lt;code&gt;TypeError&lt;/code&gt; at the evaluation of &lt;code&gt;(x + 5) &amp;gt; 0&lt;/code&gt; because its truth value
cannot be determined. The solution to this issue is given as&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;x = Symbol('x', positive=True)
if (x + 5) &amp;gt; 0:
    print('Do Something')
else:
    print('Do Something else')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Setting &lt;code&gt;x&lt;/code&gt; to be positive via &lt;code&gt;Symbol('x', positive=True)&lt;/code&gt; is correct, but
even in this case, evaluating an inequality may still raise a &lt;code&gt;TypeError&lt;/code&gt; (for
example, &lt;code&gt;if (x - 5) &amp;gt; 0&lt;/code&gt;). The better way to do this is to use &lt;code&gt;(x + 5).is_positive&lt;/code&gt;. This would require a bit more discussion, especially since
SymPy uses a three-valued logic for assumptions, but I do consider "if
&amp;lt;symbolic inequality&amp;gt;" to be a SymPy antipattern.&lt;/p&gt;
&lt;p&gt;I like Saha's approach in this chapter of first showing unevaluated forms
(&lt;code&gt;Limit&lt;/code&gt;, &lt;code&gt;Derivative&lt;/code&gt;, &lt;code&gt;Integral&lt;/code&gt;), and then evaluating them with
&lt;code&gt;doit()&lt;/code&gt;. This puts users in the mindset of a mathematical expression being a
formula which may or may not later be "calculated". The opposite approach,
using the function forms, &lt;code&gt;limit&lt;/code&gt;, &lt;code&gt;diff&lt;/code&gt;, and &lt;code&gt;integrate&lt;/code&gt;, which evaluate if
they can and return an unevaluated object if they can't, can be confusing to
new users in my experience. A common new SymPy user question is (some form of)
"how do I evaluate an expression?" (the answer is &lt;code&gt;doit()&lt;/code&gt;). Saha's approach
avoids this question by showing &lt;code&gt;doit()&lt;/code&gt; from the outset.&lt;/p&gt;
&lt;p&gt;I also like that this chapter explains the gotcha of &lt;code&gt;math.sin(Symbol('x'))&lt;/code&gt;,
although I personally would have included this earlier in the text.&lt;/p&gt;
&lt;p&gt;(Side note: now that I look, these are both areas in which the official
tutorial could be improved).&lt;/p&gt;
&lt;h3&gt;Summary&lt;/h3&gt;
&lt;p&gt;This book is a good introduction to doing math with Python, and, for the
chapters that use it, a good basic introduction to SymPy. I would recommend it
to anyone wishing to learn SymPy, but especially to anyone whose knowledge of
mathematics may preclude them from getting the most out of the official SymPy
tutorial.&lt;/p&gt;
&lt;p&gt;I imagine this book would work well as a pedagogical tool, either for math
teachers or for self-learners. The exercises in this book should push the
motivated to learn more.&lt;/p&gt;
&lt;p&gt;I have a few minor gripes, but no major issues.&lt;/p&gt;
&lt;p&gt;You can purchase this book from the
&lt;a href="https://www.nostarch.com/doingmathwithpython"&gt;No Starch Press&lt;/a&gt; website, both
as a print book or an ebook. The website also includes a sample chapter
(&lt;a href="https://www.nostarch.com/download/Doing%20Math%20with%20Python_sample_Chapter1.pdf"&gt;chapter 1&lt;/a&gt;),
code samples from the book, and exercise solutions.&lt;/p&gt;&lt;/div&gt;</description><guid>https://asmeurer.github.io/blog/posts/doing-math-with-python-by-amit-saha-book-review/</guid><pubDate>Sat, 19 Dec 2015 21:01:21 GMT</pubDate></item><item><title>Lessons learned from working at Continuum</title><link>https://asmeurer.github.io/blog/posts/lessons-learned-from-working-at-continuum/</link><dc:creator>Aaron Meurer</dc:creator><description>&lt;div&gt;&lt;p&gt;Last Friday was my last day working at Continuum Analytics. I enjoyed my
time at the company, and wish success to it, but the time has come for me to
move on. Starting later this year, I will start working with
&lt;a href="https://twitter.com/scopatz"&gt;Anthony Scopatz&lt;/a&gt; at his new lab
&lt;a href="http://www.ergs.sc.edu/index.html"&gt;ERGS&lt;/a&gt; at the University of South
Carolina.&lt;/p&gt;
&lt;p&gt;During my time at Continuum (over two years if you count a summer internship),
I primarily worked on the
&lt;a href="https://www.continuum.io/downloads"&gt;Anaconda distribution&lt;/a&gt; and its open
source package manager, &lt;a href="http://conda.pydata.org/"&gt;conda&lt;/a&gt;.  I learned a lot of
lessons in that time, and I'd like to share some of them here.&lt;/p&gt;
&lt;p&gt;In no particular order:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Left to their own devices, people will make the minimal possible solution to
  packaging. They won't try to architect something. The result will be
  over-engineered, specific to their use-case, and lack reproducibility.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The best way to ensure that some software has no bugs is for it to have many
  users.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Be wary of the "software would be great if it weren't for all the users"
  mentality (cf. the previous point).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Most people don't code defensively. If you are working on a project that
  requires extreme stability, be cautious of contributions from those outside
  the development team.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Hostility towards Windows and Windows users doesn't help anyone.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://twitter.com/asmeurer/status/593170976981913600"&gt;https://twitter.com/asmeurer/status/593170976981913600&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;For a software updater, stability is the number one priority. If the updater
  breaks, how can a fix be deployed?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Even if you configure your program to update itself every time it runs you
  will still get bug reports with arbitrarily old versions.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Separating components into separate git repositories leads to a
  philosophical separation of concerns among the components.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Everyone who isn't an active developer on the project will ignore this
  separation and open issues in the wrong repo.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Avoid object oriented programming when procedural programming will do just
  fine.&lt;sup id="fnref:fn1"&gt;&lt;a class="footnote-ref" href="https://asmeurer.github.io/blog/posts/lessons-learned-from-working-at-continuum/#fn:fn1" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Open source is more about the open than the source. Develop things in the
  open, and you will create a community that respects you.&lt;sup id="fnref:fn1"&gt;&lt;a class="footnote-ref" href="https://asmeurer.github.io/blog/posts/lessons-learned-from-working-at-continuum/#fn:fn1" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Academics (often) don't know good software practices, nor good licensing
  practices.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Neither do some large corporations.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Avoid over-engineering things.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Far fewer people than I would have thought understand the difference between
  hard links and soft links.&lt;sup id="fnref:fn2"&gt;&lt;a class="footnote-ref" href="https://asmeurer.github.io/blog/posts/lessons-learned-from-working-at-continuum/#fn:fn2" rel="footnote"&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Changelogs are useful.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Semantic versioning is over-hyped.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;If you make something and release it, the first version should be 1.0 (not
  0.1 or 0.0.1).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Getting a difficult package to compile is like hacking a computer. All it
  takes is time.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;It doesn't matter how open source friendly your business is, there will
  always be people who will be skeptical and point their fingers at the
  smallest proprietary components, fear monger, and overgeneralize unrelated
  issues into FUD. These people should generally be ignored.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Don't feed the trolls.&lt;sup id="fnref:fn1"&gt;&lt;a class="footnote-ref" href="https://asmeurer.github.io/blog/posts/lessons-learned-from-working-at-continuum/#fn:fn1" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;People constantly misspell the name of
  &lt;a href="https://twitter.com/asmeurer/status/618595687958122496"&gt;Apple's desktop operating system&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;People always assume you have way more automation than you really do.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The Python standard library is not a Zen garden. Some parts of it are
  completely broken, and if you need to rely on them, you'll have to rewrite
  them. &lt;code&gt;shutil.rmtree&lt;/code&gt; on Windows is one example of this.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Linux is strictly backwards compatible. Windows is strictly forwards
  compatible. &lt;sup id="fnref:fn3"&gt;&lt;a class="footnote-ref" href="https://asmeurer.github.io/blog/posts/lessons-learned-from-working-at-continuum/#fn:fn3" rel="footnote"&gt;3&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;On Linux, things tend to be very simple. On Windows, things tend to be very
  complicated.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;I can't decide about OS X. It lies somewhere in between.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Nobody uses 32-bit Linux. Why do we even support that?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;People oversimplify the problem of solving for package dependencies in their
  heads.  No one realizes that it's meaningless to say something like "the
  dependencies of NumPy" (every build of every version of NumPy has its own
  set of dependencies, which may or may not be the same).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Writing a set of rules and a solver to solve against those rules is
  relatively easy. Writing heuristics to tell users why those rules are
  unsolvable when they are is hard.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SAT solvers solve NP-complete problems in general, but they can be very fast
  to solve common case problems. &lt;sup id="fnref:fn1"&gt;&lt;a class="footnote-ref" href="https://asmeurer.github.io/blog/posts/lessons-learned-from-working-at-continuum/#fn:fn1" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Some of the smartest people I know, who otherwise make very rational and
  intelligent decisions,
  &lt;a href="https://asmeurer.github.io/python3-presentation/slides.html"&gt;refuse to update to Python 3&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;As an introvert, the option of working from home is great for maintaining
  sanity.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://blog.codinghorror.com/a-developers-second-most-important-asset/"&gt;Aeron chairs are awesome&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;If living in Austin doesn't turn you into a foodie you will at least gain a
  respect for them.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Twitter, if used correctly, is a great way to interact with your users.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Twitter is also a great place to learn new things. Follow
  &lt;a href="https://twitter.com/JohnDCook"&gt;John Cook&lt;/a&gt; and
  &lt;a href="https://twitter.com/worrydream"&gt;Bret Victor&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;One of the best ways to make heavily shared content is to make it about git
  (at least if you're an expert).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A good optimization algorithm avoids getting caught in local maxima by
  trying different parts of the search space that initially appear to be
  worse. The same approach should be taken in life.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Footnotes&lt;/h4&gt;
&lt;div class="footnote"&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id="fn:fn1"&gt;
&lt;p&gt;These are things that I already knew, but were reiterated. &lt;a class="footnote-backref" href="https://asmeurer.github.io/blog/posts/lessons-learned-from-working-at-continuum/#fnref:fn1" rev="footnote" title="Jump back to footnote 1 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:fn2"&gt;
&lt;p&gt;If you are one of those people, I have a small presentation that
   explains the difference &lt;a href="https://speakerdeck.com/asmeurer/hard-links-and-soft-links"&gt;here&lt;/a&gt; &lt;a class="footnote-backref" href="https://asmeurer.github.io/blog/posts/lessons-learned-from-working-at-continuum/#fnref:fn2" rev="footnote" title="Jump back to footnote 2 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:fn3"&gt;
&lt;p&gt;These terms can be confusing, and I admit I got this backwards the
    first time I wrote this. According to Wikipedia,
    &lt;a href="https://en.wikipedia.org/wiki/Forward_compatibility"&gt;forwards compatible&lt;/a&gt;
    means a system can accept input intended for a later version of itself
    and
    &lt;a href="https://en.wikipedia.org/wiki/Backward_compatibility"&gt;backwards compatible&lt;/a&gt;
    means a system can accept input intended for an earlier version of
    itself.&lt;/p&gt;
&lt;p&gt;What I specifically mean here is that in terms of building packages
for Linux or Windows, for Linux, you should build a package on the
oldest version that you wish to support. That package will work on
newer versions of Linux, but not anything older (generally due to the
version of libc you are linked against).&lt;/p&gt;
&lt;p&gt;On the other hand, on Windows, you can can compile things on the
newest version (I used Windows 8 on my main Windows build VM), and it
will work on older versions of Windows like XP (as long as you ship
the right runtime DLLs). This is also somewhat confusing because
Windows tends to be both forwards compatible &lt;em&gt;and&lt;/em&gt; backwards
compatible. &lt;a class="footnote-backref" href="https://asmeurer.github.io/blog/posts/lessons-learned-from-working-at-continuum/#fnref:fn3" rev="footnote" title="Jump back to footnote 3 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;&lt;/div&gt;</description><guid>https://asmeurer.github.io/blog/posts/lessons-learned-from-working-at-continuum/</guid><pubDate>Mon, 05 Oct 2015 22:29:03 GMT</pubDate></item><item><title>Python Trickery</title><link>https://asmeurer.github.io/blog/posts/python-trickery/</link><dc:creator>Aaron Meurer</dc:creator><description>&lt;div&gt;&lt;p&gt;Here are some bits of Python trickery that I have come across. Each of the
following is invalid syntax.  See if you can figure out why&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;/li&gt;&lt;/ol&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;1 + not(2)
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start="2"&gt;
&lt;li&gt;
&lt;/li&gt;&lt;/ol&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;f(*(
i for i in range(10)
if i % 2),
x=3,)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description><guid>https://asmeurer.github.io/blog/posts/python-trickery/</guid><pubDate>Mon, 04 May 2015 19:11:46 GMT</pubDate></item><item><title>Playing with Swift and SpriteKit</title><link>https://asmeurer.github.io/blog/posts/playing-with-swift-and-spritekit/</link><dc:creator>Aaron Meurer</dc:creator><description>&lt;div&gt;&lt;p&gt;I've always wanted to learn how to write native apps for iOS and the Mac as
long as either has existed.  However, the barrier of entry has always been too
high, given that I only ever had time to play with them as a hobby.  The
Objective-C programming language is a bit complicated to learn, especially
alongside all the memory management that you have to do (and it doesn't help
that Apple has gone through several memory management schemes through Mac OS X
versions).  To add on to that, the Cocoa framework is huge, and it's quite
daunting to even know where to get started with it.&lt;/p&gt;
&lt;p&gt;With Apple's announcement of the
&lt;a href="https://developer.apple.com/swift/"&gt;Swift programming language&lt;/a&gt; in June, it
was clear to me that the language would significantly lower the barrier of
entry.  The &lt;a href="https://developer.apple.com/xcode/downloads/"&gt;XCode 6 beta&lt;/a&gt; is
now public (i.e., you do not need to have a paid Apple Developer account to
access it), so anyone can play with Swift.&lt;/p&gt;
&lt;p&gt;Note that I am still &lt;em&gt;very&lt;/em&gt; new to both Swift and iOS development in general,
so it's quite likely that some of the things I mention here are actually bad
ideas.  If you know more than I do and spot a bad thing that I am doing,
please mention it in the comments.&lt;/p&gt;
&lt;p&gt;It's also possible that some of the assumptions I've made about the Swift
language or the SpriteKit framework are actually wrong. Please remember that I
am still a beginner and take what I say with a grain of salt.&lt;/p&gt;
&lt;h2&gt;The Swift Language&lt;/h2&gt;
&lt;p&gt;If you don't know how to program at all, I don't know how well this will work
for you. I already know several language, especially Python, so my experience
derives from that.&lt;/p&gt;
&lt;p&gt;First, read through the
&lt;a href="https://developer.apple.com/swift/resources/"&gt;Swift language guide&lt;/a&gt;. If you
have XCode 6, you can read it interactively as a Playground. I only have read
through the first part so far, which gives a high-level overview of the
language.&lt;/p&gt;
&lt;p&gt;The Swift language is actually quite easy to learn, especially if you already
know a high-level language like Python.  A few important things:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;var&lt;/code&gt; and &lt;code&gt;let&lt;/code&gt; seem a bit confusing.  The difference is actually quite
simple: &lt;code&gt;var&lt;/code&gt; denotes a variable that can change and &lt;code&gt;let&lt;/code&gt; denotes a
variable that cannot.  You could in theory just use &lt;code&gt;var&lt;/code&gt; for everything,
but &lt;code&gt;let&lt;/code&gt; lets the compiler spot mistakes for you, and it also probably lets
it make your code faster.  If you intend to never change the value of a
variable, use &lt;code&gt;let&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Swift uses type inference, meaning that you usually don't need to specify
types. But when you do, you do so by putting a &lt;code&gt;:&lt;/code&gt; after the variable name,
like &lt;code&gt;var a: Int = 2&lt;/code&gt; or &lt;code&gt;func f(a: Int)&lt;/code&gt;.  The exception is the return type
of a function, which uses the arrow &lt;code&gt;-&amp;gt;&lt;/code&gt; (if you are familiar with Python 3
type annotations, the syntax is exactly the same), &lt;code&gt;func f(a: Int) -&amp;gt; Int&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Swift uses &lt;code&gt;?&lt;/code&gt; after a type name to indicate that a variable could be its
given type, or &lt;code&gt;nil&lt;/code&gt;. If you are familiar with Haskell, this is like the
Maybe monad.  I know very little Haskell, so I don't know if Swift's
implementation of &lt;code&gt;?&lt;/code&gt; is truly a Monad.&lt;/p&gt;
&lt;p&gt;Roughly speaking, in many circumstances, you don't know if a variable will
actually be the given type or not. A good example of this is with
dictionaries. &lt;code&gt;var a: [String: Int]&lt;/code&gt; creates a dictionary that maps
strings to integers. If you manipulate this dictionary, and then access a
key from it, like &lt;code&gt;a[b]&lt;/code&gt;, there is no way for the compiler to know if that
key will really be in the dictionary. If the key is in the dictionary, you
will get the value of that key. Otherwise, you will get &lt;code&gt;nil&lt;/code&gt;. Hence, the
type of &lt;code&gt;a[b]&lt;/code&gt; is &lt;code&gt;Int?&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Swift uses &lt;code&gt;!&lt;/code&gt; to indicate that the value is not &lt;code&gt;nil&lt;/code&gt;, which tells the
compiler to compile code that doesn't check for that case.&lt;/p&gt;
&lt;p&gt;For the most part, you can ignore this as well, at least when you
start. Just write code as you would, let XCode add in the types for you, and
only worry about types if the compiler tells you something is wrong.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Swift functions often require the parameters be named, for instance, you
have to write &lt;code&gt;CGSize(width: 1, height: 2)&lt;/code&gt; instead of just &lt;code&gt;CGSize(1, 2)&lt;/code&gt;. This is both for clarity (the former is much easier to read if you
aren't familiar with the API for &lt;code&gt;CGSize&lt;/code&gt;), and because Swift allows
polymorphism, i.e., you can define different initializers for the same class
with different type signatures. For example, &lt;code&gt;CGRect&lt;/code&gt; can be initialized as
&lt;code&gt;CGRect(origin: CGPoint, size: CGSize)&lt;/code&gt; or &lt;code&gt;CGRect(x: Int, y: Int, width: Int, height: Int)&lt;/code&gt;. This can lead to ambiguities in some cases unless you
explicitly tell the compiler which version to use.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I've found Swift to be a very strict language. I don't mean this in the sense
described by
&lt;a href="https://en.wikipedia.org/wiki/Strict_programming_language"&gt;this Wikipedia article&lt;/a&gt;. What
I mean is that Swift typically only lets you do things one way.  This is
similar to Python's "one way to do it," except Swift enforces this at the
language level.&lt;/p&gt;
&lt;p&gt;A nice example of this is that I rarely get a warning from the Swift compiler.
Just about every message I've gotten from the compiler has been an error. The
difference is that the program will still compile and run with a warning. This
is different from C, C++, and Objective-C, which have many warnings that the
compiler will still compile with. These warnings usually are for things like
an incorrect pointer type. Since there is really only one type in C, the
integer (because all data in memory is just integers), the program can still
run even if you mix your types up a bit.&lt;/p&gt;
&lt;p&gt;There are also many cases where Swift seems maybe too strict about things,
although it's clear that it is doing it to try to stray people away from
common mistakes and antipatterns. For example, the condition of an &lt;code&gt;if&lt;/code&gt;
statement in Swift must always be of type &lt;code&gt;Bool&lt;/code&gt;. Unlike languages like
Python, things do not have implicit boolean values. &lt;code&gt;if 1&lt;/code&gt; is a syntax
error. So is &lt;code&gt;if a&lt;/code&gt; unless &lt;code&gt;a&lt;/code&gt; is type &lt;code&gt;Bool&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This ends up not being a big problem. The things Swift forces you to do feel
like good programming practices.  This is not unlike how Python "forces" you
to keep your code indented correctly.  It feels very different from a language
like Java, where the things that you are forced to do all feel like they are
there simply to make the compiler writer's life easier.  And indeed, unlike
Java and Objective-C and much like Python, Swift code requires very little
boilerplate.  There are no header files for instance.&lt;/p&gt;
&lt;p&gt;So all said and done, I like Swift. I don't like it as much as Python (I also
don't have my head wrapped around it as much as Python). But it's far better
than Objective-C, and that's what matters. Frankly, my biggest gripe with it
is the ubiquitous use of CamelCasing and two letter prefixing (&lt;code&gt;NS&lt;/code&gt;, &lt;code&gt;CG&lt;/code&gt;,
&lt;code&gt;SK&lt;/code&gt;; I don't know if there's a name for this) in the API. I adamantly refuse
to do this with my own variables, because I believe CamelCase reduces
readability over underscore_casing. I like the Python convention to use
underscore_casing for variables, functions, and methods, and CamelCase for
classes (because classes are kind of like proper nouns, and CamelCase is as
close to Capitalization as possible in programming language conventions).&lt;/p&gt;
&lt;h2&gt;Learn to read Objective-C&lt;/h2&gt;
&lt;p&gt;While it is not necessary to write Objective-C any more, it is a good idea to
know how to read it. The reason is that a lot of good resources on the
internet are still in Objective-C (also a lot of Apple's example
documentation). The API names are the same, so this mainly boils down to
understanding how to convert the basic syntax to Swift. Reading the section of
the &lt;a href="https://en.wikipedia.org/wiki/Objective_C#Syntax"&gt;Wikipedia article&lt;/a&gt; on
the syntax of Objective-C should be enough.&lt;/p&gt;
&lt;p&gt;For instance&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-objective-c"&gt;[touch locationInNode:self]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;would be translated to&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-swift"&gt;touch.locationInNode(self)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Use XCode&lt;/h2&gt;
&lt;p&gt;If you are comfortable with the Swift language itself, you should get started
with a project.&lt;/p&gt;
&lt;p&gt;First off, you should use XCode to edit your code, at least to begin with,
even if you are accustomed to using another editor.  The reason is that XCode
is going to do a lot of things for you which will make your life easier and
reduce the complexity significantly as you get started.  Once you are
comfortable, you can move to another editor.&lt;/p&gt;
&lt;p&gt;Some things that XCode will do for you:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Autocompletion&lt;/strong&gt;: The best way to figure out the Cocoa APIs is to use the
autocompletion. This pops up when you want to override a method in a
subclass, create an object from an existing class, access an attribute of a
class, or instantiate a class or call a function (remember that Swift is
polymorphic, so it's useful to know all the possible ways to instantiate a
class or call a function).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Compiler errors and warnings&lt;/strong&gt;: Swift, being a strictly typed language,
will give you a lot of useful compiler errors. It's pretty hard to write a
program incorrectly from a type point of view, and have it even compile.
XCode integrates this nicely, and it even offers suggestions on how to fix
things every once in a while (so that you can just click the button and have
it fixed inline).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Direct interaction with the iOS Simulator&lt;/strong&gt;: One button will compile your code
and start the simulator. If your target is Mac OS X, it will open the
application.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Debugger&lt;/strong&gt;: Clicking to the left of a line will set a breakpoint in the
debugger.  The Swift debugger seems pretty limited right now. I wasn't able
to get any useful information out of the variables view when I used it.  But
in my experience using XCode in the past to debug C, its graphical debugger
is one of the best.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Configuration settings&lt;/strong&gt;: If you click on the XCode project in the files
view (the root node of all the files), you get a view with all the different
settings for your project. Most of these you probably won't want to change,
but a few are important, like what devices and orientations you want to
allow, what operating system versions you want to support, and the name and
version of your project.  Editing these outside of XCode requires editing an
XML file, which is no fun.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Of course, any editor can potentially do these things, and I'm really looking
forward to the point where I can just use Emacs to edit Swift code, as the
XCode editor as an editor is quite annoying.  XCode was the editor that I used
before I switched to using Emacs, and it's not gotten much better. There are
still several visual glitches in the editor environment, especially with the
scope coloring and syntax highlighting. You can edit the keyboard shortcuts in
the XCode setting to get some things the way you like them (although I found
that trying to set TAB to autoindent did not work). You can also use a tool
like &lt;a href="https://pqrs.org/osx/karabiner/"&gt;Karabiner&lt;/a&gt; (previously
KeyRemap4MacBook) to enable Vim or Emacs editor shortcuts everywhere
(including XCode). It doesn't help that XCode 6 is still in beta (at some
point the editor backend died and all syntax highlighting and tab completion
stopped working; I managed to fix it by removing a spurious &lt;code&gt;!&lt;/code&gt; in the code)&lt;/p&gt;
&lt;h2&gt;The iOS Simulator&lt;/h2&gt;
&lt;p&gt;One disappointing thing that I learned is that you cannot run any iOS program
you write on an iOS device unless you are in the paid developer program (or if
you Jailbreak and are willing to go through some hoops). The iOS developer
program costs $100 a year, and since I'm not sure yet how far I am going to go
with this, I am holding off on it.&lt;/p&gt;
&lt;p&gt;The only other option then is to run on the simulator. The simulator is fine,
the only issue is that there are limits to how you can simulate a touch screen
on a computer with a mouse.&lt;/p&gt;
&lt;p&gt;A few things to note about the simulator:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;There are several things you can do with the "hardware" from the hardware
menu, such as rotating the device or pressing the home button.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;It's worth remembering the keyboard shortcut for pressing the home button,
⇧⌘H, as you can press it twice in quick succession just like on a real
device to open the task manger. You can then drag your app up to completely
reset it, without having to restart the simulator.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The retina iPad is taller than your display, even if you have a 15" retina
display. So be aware that you will need to scroll up and down to see it
all. Alternately, you can use a smaller device, like an iPhone, or rotate it
to landscape, where it all fits.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The only way to do multitouch is to hold down the Option key. This will
create two fingers.  However, it's quite limited as the two fingers are
always centered around the center of the screen. Therefore if you want to
test multitouching two objects, you'll have to position them symmetrically so
that you can grab them both.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Getting started with a project&lt;/h2&gt;
&lt;p&gt;The best way to start is to start a template project with XCode. I personally
started with a SpriteKit game for iOS. This created a basic template "Hello
World" Swift file with the basic &lt;code&gt;SKScene&lt;/code&gt; subclass. Go ahead and compile and
run this in the simulator to see what it does.&lt;/p&gt;
&lt;p&gt;There are four important methods of &lt;code&gt;SKScene&lt;/code&gt; which you will want to override,
&lt;code&gt;didMoveToView&lt;/code&gt;, &lt;code&gt;touchesBegan&lt;/code&gt;, &lt;code&gt;touchesEnded&lt;/code&gt;, and &lt;code&gt;update&lt;/code&gt;. &lt;code&gt;didMoveToView&lt;/code&gt;
is the initializer for the scene.  Anything that should be set up and appear
from the very beginning should go there. &lt;code&gt;touchesBegan&lt;/code&gt; and &lt;code&gt;touchesEnded&lt;/code&gt; are
called when a finger touches the screen and when it leaves the screen,
respectively. Remember always that iOS devices are multitouch devices, so
these events can happen concurrently, and there can be multiple touches
happening at once.  The first argument to these methods is a set of touches,
which you should iterate over to perform actions (the "Hello World" example
shows how to do this). Finally, the &lt;code&gt;update&lt;/code&gt; method is called every time the
scene is updated, at each "frame" essentially.&lt;/p&gt;
&lt;p&gt;There are other methods, for instance, &lt;code&gt;touchesMoved&lt;/code&gt;. However, I discovered
that you don't actually want to use &lt;code&gt;touchesMoved&lt;/code&gt; to do what you would think
you'd use it for, namely, to move stuff around. The reason is that there is no
easy way to sync up multitouches between &lt;code&gt;touchesBegan&lt;/code&gt; (where you know what
thing the finger started on) and &lt;code&gt;touchesMoved&lt;/code&gt; to move it around. It works
well for a single touch, but if you want to be able to move multiple things
around at once (which I highly recommend, as it leads to a much nicer user
experience), you have to do things a little differently, as I'll explain
below.&lt;/p&gt;
&lt;h2&gt;Adding some objects to your environment&lt;/h2&gt;
&lt;p&gt;There are a lot of classes to create various objects of various shapes. I
started with &lt;code&gt;SKSpriteNode&lt;/code&gt;, which creates a simple square, because I wanted
to play around with touch events.&lt;/p&gt;
&lt;p&gt;I started out with four sprites (yes, it would be better to put these in an
array, and probably abstract them to a method):&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-swift"&gt;let sprite1 = SKSpriteNode(color: UIColor(red: 1.0, green: 0.0, blue: 0.0, alpha: 1.0), size: CGSize(width: 30, height: 30))
let sprite2 = SKSpriteNode(color: UIColor(red: 0.0, green: 1.0, blue: 0.0, alpha: 1.0), size: CGSize(width: 30, height: 30))
let sprite3 = SKSpriteNode(color: UIColor(red: 0.0, green: 0.0, blue: 1.0, alpha: 1.0), size: CGSize(width: 30, height: 30))
let sprite4 = SKSpriteNode(color: UIColor(red: 1.0, green: 1.0, blue: 0.0, alpha: 1.0), size: CGSize(width: 30, height: 30))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;These lines go at the class level. This lets them be accessed from within any
method of the class.&lt;/p&gt;
&lt;p&gt;One thing I could not figure out how to do was how to access class variables
from within other class variables.  In Python, you can do&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;class Test:
    a = 1
    b = a + 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But in Swift, if you do&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-swift"&gt;class Test {
    let a = 1
    let b = a + 1
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;it tells you that &lt;code&gt;Test.Type does not have a member named 'a'&lt;/code&gt; on the &lt;code&gt;let b = a + 1&lt;/code&gt; line.&lt;/p&gt;
&lt;p&gt;You may have to use properties with getters and setters in this case, which I
didn't feel like fooling with. The result is that I did not abstract out the
&lt;code&gt;CGSize(width: 30, height: 30)&lt;/code&gt; into a common variable.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;didMoveToView&lt;/code&gt; method then becomes&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-swift"&gt;override func didMoveToView(view: SKView) {
    let center = CGPoint(x:CGRectGetMidX(self.frame), y:CGRectGetMidY(self.frame))

    for s in [sprite1, sprite2, sprite3, sprite4] {
        s.position = center

        self.addChild(s)
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;self.addChild&lt;/code&gt; is the most important method here, as it actually puts the
sprite in the main view. If you forget this line, none of the sprites will
show up.&lt;/p&gt;
&lt;p&gt;If you run this, you will only see the yellow box, because you put them all on
top of one another in the center of the view.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://asmeurer.github.io/blog/galleries/swift-game-1.png" width="500"&gt;&lt;/p&gt;
&lt;h2&gt;Adding Basic Physics&lt;/h2&gt;
&lt;p&gt;We could change the positions so that they do not overlap, but the option I
went with was to play around with the physics a little. &lt;code&gt;SpriteKit&lt;/code&gt; has a nice
2D physics engine built in, and it's quite easy to use.&lt;/p&gt;
&lt;p&gt;So my final &lt;code&gt;didMoveToView&lt;/code&gt; was&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-swift"&gt;override func didMoveToView(view: SKView) {
    /* Setup your scene here */
    let center = CGPoint(x:CGRectGetMidX(self.frame), y:CGRectGetMidY(self.frame))

    for s in [sprite1, sprite2, sprite3, sprite4] {
        s.position = center

        var physics_body = SKPhysicsBody(rectangleOfSize: CGSize(width: 30, height: 30))

        physics_body.affectedByGravity = false
        physics_body.allowsRotation = false

        s.physicsBody = physics_body
        self.addChild(s)
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For each sprite, I create an &lt;code&gt;SKPhysicsBody&lt;/code&gt; with the exact same size as the
&lt;code&gt;SKSpriteNode&lt;/code&gt;s (there's probably a more direct way to do this), and attach it
to that node. The &lt;code&gt;affectedByGravity&lt;/code&gt; property is important. If you don't set
it to &lt;code&gt;false&lt;/code&gt;, all the objects will fall off the bottom of the screen. I
disabled &lt;code&gt;allowsRotation&lt;/code&gt; because I wanted my squares to stay
upright. Otherwise when when the squares hit one another they will rotate in
space.&lt;/p&gt;
&lt;p&gt;Now &lt;code&gt;SceneKit&lt;/code&gt; will prevent the squares from overlapping with one another, even
if we put them on top of each other as we have done.&lt;/p&gt;
&lt;p&gt;So now when we start the simulator, we see&lt;/p&gt;
&lt;p&gt;&lt;img src="https://asmeurer.github.io/blog/galleries/swift-game-2.png" width="500"&gt;&lt;/p&gt;
&lt;h2&gt;Making the squares movable&lt;/h2&gt;
&lt;p&gt;Now, let's make it so that we can move these squares around.  The correct way
to do this took me some time to figure out.  I finally got some hints from
&lt;a href="http://eppz.eu/blog/spritekit-drag/"&gt;this site&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The key thing here is that the &lt;code&gt;UITouch&lt;/code&gt; objects remain the same objects for
the duration of the touch. Their position is updated when the touch
moves. Hence, you just need to associate each touch with the node that was
touched when the touch began, and move the node to the position of that touch
with each update.&lt;/p&gt;
&lt;p&gt;To start, we will create a dictionary on the class mapping touches to nodes&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-swift"&gt;var selected: [UITouch: SKNode] = [:]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then, in the &lt;code&gt;touchesBegan&lt;/code&gt; method, map every touch to the node that it
touches.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-swift"&gt;override func touchesBegan(touches: NSSet, withEvent event: UIEvent) {
    /* Called when a touch begins */

    selected = [:]
    for touch: AnyObject in touches {
        let location = touch.locationInNode(self)

        selected[touch as UITouch] = nodeAtPoint(location)

    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;as UITouch&lt;/code&gt; part is needed because the compiler only knows that touch is
&lt;code&gt;AnyObject&lt;/code&gt;. This was one of the things that was helpfully suggested by the
compiler, so I did not really need to know what I was doing to get it right.&lt;/p&gt;
&lt;p&gt;Note that even if you touch the background behind the squares, you are still
touching a node, namely, the &lt;code&gt;GameScene&lt;/code&gt; node itself (the node for the class
you are working on).  This is a very important observation, as it will tell us
how to get the right position for the node when we update it. It also means
that we should keep track of which nodes we actually want to be moved by the
touch. Trying to move the &lt;code&gt;GameScene&lt;/code&gt; node is ignored, at leads to a lot of
console logs, so we should avoid it.&lt;/p&gt;
&lt;p&gt;Next, let's write the &lt;code&gt;touchesEnded&lt;/code&gt; method. This method is simple. If a touch
ends (the finger is removed from the screen), we should remove it from the
&lt;code&gt;selected&lt;/code&gt; dictionary.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-swift"&gt;override func touchesEnded(touches: NSSet, withEvent event: UIEvent) {
    for touch: AnyObject in touches {
    selected[touch as UITouch] = nil
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To delete an item from a dictionary in Swift, just set it to &lt;code&gt;nil&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Now, finally, we need to write the &lt;code&gt;update&lt;/code&gt; method to move the node to the
current position of the touch.&lt;/p&gt;
&lt;p&gt;The simplest way to do this is&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-swift"&gt;override func update(currentTime: CFTimeInterval) {
    /* Called before each frame is rendered */
    for (touch, node) in selected {
        if !contains([sprite1, sprite2, sprite3, sprite4], node) {
            continue
        }
        let location = touch.locationInNode(self)
        node.position = location
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that we only modify the position for the four sprite nodes.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;touch.locationInNode(self)&lt;/code&gt; part took me a long time to figure out. There
are other methods, like &lt;code&gt;touch.locationInView(nil)&lt;/code&gt;, but this does something
very strange where the the horizontal axis was doubled (moving the touch one
inch moved the object two inches), and the vertical axis was inverted. If
someone knows what was going on there, please let me know.&lt;/p&gt;
&lt;p&gt;Modifying the position directly is nice, but it's nice to play around a little
bit with a third thing from SpriteKit, actions.&lt;/p&gt;
&lt;p&gt;What we will do instead of setting the position of the node is to tell
SpriteKit to move the node there in a certain amount of time. If we make this
time small enough, like &lt;code&gt;0.01&lt;/code&gt; seconds, it will appear to act exactly the
same. If we up this time, there will be a smooth "lag" where the node catches
up to the touch. Because the movement always happens in the same amount of
time, it will move faster if the finger is farther away. This gives the
squares a nice "frictioney" effect with some springiness to it, which is quite
nice.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-swift"&gt;override func update(currentTime: CFTimeInterval) {
    /* Called before each frame is rendered */
    for (touch, node) in selected {
        if !contains([sprite1, sprite2, sprite3, sprite4], node) {
            continue
        }
        let location = touch.locationInNode(self)
        let action = SKAction.moveTo(location, duration: 0.1)
        node.runAction(SKAction.repeatAction(action, count: 1))
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There are many other actions we can perform, like rotations and color
changes.&lt;/p&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;Here is an example of the movement. You can see it works even with
multitouch.  You can also see the collision physics cause the other squares to
move out of the way when another square hits them.&lt;/p&gt;
&lt;video src="https://asmeurer.github.io/blog/SpriteKit-Example.mp4" autoplay width="500" loop&gt;
  Your browser does not support the video tag.
&lt;/video&gt;
&lt;p&gt;Here you can see the movement lag caused by using &lt;code&gt;SKAction.moveTo&lt;/code&gt; with
&lt;code&gt;duration: 0.1&lt;/code&gt; (note that the mouse itself jumps a bit at the beginning, but
this is due to lag in the recording).&lt;/p&gt;
&lt;video src="https://asmeurer.github.io/blog/SpriteKit-Example-2.mp4" autoplay width="500" loop&gt;
  Your browser does not support the video tag.
&lt;/video&gt;
&lt;p&gt;I have uploaded the full code to
&lt;a href="https://github.com/asmeurer/GameTest/blob/blog/GameTest/GameScene.swift"&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;This isn't exactly a "game", but it does lay down the foundations for what you
would need to write a game in Swift using SpriteKit.  At least for me, it
shows me the technical basics of how to write some games that I had thought
about, which mostly involve making shapes and moving them around the screen.&lt;/p&gt;
&lt;!--  LocalWords:  func Haskell CGSize CGRect CGPoint locationInNode SKScene
 --&gt;
&lt;!--  LocalWords:  touch.locationInNode Karabiner KeyRemap4MacBook SpriteKit
 --&gt;
&lt;!--  LocalWords:  didMoveToView touchesBegan touchesEnded touchesMoved py
 --&gt;
&lt;!--  LocalWords:  SKSpriteNode sprite1 UIColor sprite2 sprite3 sprite4 'a'
 --&gt;
&lt;!--  LocalWords:  Test.Type SKView CGRectGetMidX self.frame CGRectGetMidY
 --&gt;
&lt;!--  LocalWords:  s.position self.addChild img src SKPhysicsBody SceneKit
 --&gt;
&lt;!--  LocalWords:  rectangleOfSize body.affectedByGravity body.allowsRotation
 --&gt;
&lt;!--  LocalWords:  s.physicsBody affectedByGravity allowsRotation UITouch
 --&gt;
&lt;!--  LocalWords:  SKNode NSSet withEvent UIEvent AnyObject nodeAtPoint
 --&gt;
&lt;!--  LocalWords:  GameScene currentTime CFTimeInterval node.position
 --&gt;
&lt;!--  LocalWords:  frictioney SKAction.moveTo node.runAction autoplay
 --&gt;
&lt;!--  LocalWords:  SKAction.repeatAction
 --&gt;&lt;/div&gt;</description><guid>https://asmeurer.github.io/blog/posts/playing-with-swift-and-spritekit/</guid><pubDate>Sun, 17 Aug 2014 16:31:11 GMT</pubDate></item><item><title>SciPy 2014</title><link>https://asmeurer.github.io/blog/posts/scipy-2014/</link><dc:creator>Aaron Meurer</dc:creator><description>&lt;div&gt;&lt;p&gt;I just finished &lt;a href="https://conference.scipy.org/scipy2014/"&gt;SciPy 2014&lt;/a&gt;, a
week-long conference in Austin, TX for scientific computing with Python.&lt;/p&gt;
&lt;p&gt;This is my third SciPy (I have been to
&lt;a href="https://asmeurersympy.wordpress.com/2011/07/17/the-scipy-2011-conference/"&gt;2011&lt;/a&gt;
and &lt;a href="https://asmeurersympy.wordpress.com/2013/07/02/scipy-2013/"&gt;2013&lt;/a&gt;). This
year, the conference was noticeably larger. Last year there were
&lt;a href="http://andy.terrel.us/blog/2013/07/05/scipy2013-recap/"&gt;~350 people&lt;/a&gt;, this
year, there were
&lt;a href="https://twitter.com/scopatz/status/488370261150818304"&gt;~450 people&lt;/a&gt;.  Aside
from there being a lot more people, and the main keynotes taking place in a
larger room, the most noticeable consequence of this is that there were three
days of talks this year, and three concurrent tracks of talks all three days
(last year there were two of each). The conference consisted of two days of
tutorials, three days of talks, and two days of sprints, running from July 5
to July 12.&lt;/p&gt;
&lt;h2&gt;Tutorials&lt;/h2&gt;
&lt;p&gt;The conference started on Sunday with tutorials. I gave a tutorial on SymPy
with &lt;a href="http://matthewrocklin.com/blog/"&gt;Matthew Rocklin&lt;/a&gt; and
&lt;a href="http://www.moorepants.info/blog/"&gt;Jason Moore&lt;/a&gt;. The videos are on YouTube
(parts &lt;a href="https://www.youtube.com/watch?v=Lgp442bibDM"&gt;one&lt;/a&gt;,
&lt;a href="https://www.youtube.com/watch?v=_PTe10whFKo"&gt;two&lt;/a&gt;,
&lt;a href="https://www.youtube.com/watch?v=qleGSnrnxgc"&gt;three&lt;/a&gt;, and
&lt;a href="https://www.youtube.com/watch?v=04AGOl1P2U4"&gt;four&lt;/a&gt;).  I gave tutorials for
SymPy the previous two times I was at SciPy, although with different people
(with Mateusz Paprocki in 2011 and
&lt;a href="http://ondrejcertik.blogspot.com/"&gt;Ondřej Čertík&lt;/a&gt; in 2013). I really enjoy
seeing new people learn about SymPy, and working with Matthew Rocklin, who is
a very good speaker and teacher.&lt;/p&gt;
&lt;p&gt;I also attended the tutorial on PyDy by Jason Moore, Gilbert Gede, and
Obinna Nwanna (parts &lt;a href="https://www.youtube.com/watch?v=lWbeuDwYVto"&gt;one&lt;/a&gt;
and &lt;a href="https://www.youtube.com/watch?v=1-KqRvNX0po"&gt;two&lt;/a&gt;).  This tutorial was
also well done, and I highly recommend it if you are interested in Newtonian
mechanics.&lt;/p&gt;
&lt;p&gt;I unfortunately was unable to attend any of the other tutorials, but I heard
good things about them, especially the
&lt;a href="https://www.youtube.com/watch?v=vWkgEddb4-A"&gt;Julia tutorial&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Talks&lt;/h2&gt;
&lt;p&gt;From Tuesday to Thursday were talks. The quality of talks this year was very
high. The SciPy talks have always been high quality talks, but this year I
felt that they were particularly good. I don't think I saw a bad talk.&lt;/p&gt;
&lt;p&gt;Thus, I can't really recommend the good talks that I saw without recommending
all of them. You should go to YouTube and the
&lt;a href="https://conference.scipy.org/scipy2014/schedule/"&gt;SciPy schedule&lt;/a&gt; and watch
any talk that looks interesting.&lt;/p&gt;
&lt;p&gt;I therefore am going to recommend here the very best talks.  Two talks in
particular stood out to me as the best.&lt;/p&gt;
&lt;p&gt;First is Greg Wilson's Thursday keynote, which is among the best talks I've
ever seen from any conference.&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;center&gt;&lt;iframe width="560" height="315" src="//www.youtube.com/embed/1e26rp6qPbA" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;&lt;/center&gt;
&lt;p&gt;Greg mentions a lot of ideas, quite a few of which are controversial, which I
think always makes for an interesting talk (it also means that I don't agree
with everything he said, although I do agree with most of it). Most of the
talk is about pedagogy, especially regarding his experiences at
&lt;a href="http://software-carpentry.org/"&gt;Software Carpentry&lt;/a&gt;. Some things he posited:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;There is actually good research about what methods work and don't work in
teaching. He referenced
&lt;a href="http://www.slideshare.net/richardcookau/john-hattie-effect-sizes-on-achievement"&gt;this presentation&lt;/a&gt;,
which lists just about every possible pedagogical method, and the net
difference that it has on students, based on over 50,000 studies. For
example, individualized instruction has a very small positive effect,
whereas teacher feedback has a very large positive effect. Since each takes
time and resources, we should focus on those effects that have the highest
impact. Greg pointed out that web-based learning has very little positive
effect, and hence is a waste of time and money. The most effective change is
removing disruptive students.&lt;/p&gt;
&lt;p&gt;In particular, I liked the quote, "if you want more computing in high
school, you have to tell me what to take out."  People like to go on that
schools need to teach more of this or more of that, and computing and
programming tends to be high on that list these days, but anyone who does
not discuss what things should be removed from the curriculum, which is
already quite full, is not being honest about the discussion.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The other big point Greg made is that we need more incremental massive
collaboration in teaching. This is the same model that has built open source
and Wikipedia, but is mostly absent from teaching. Incremental change is
important here, as well. It is more useful for someone to contribute fixes
to existing lesson plans, so that they become better for the students, but
in his experience, people are much more willing to add new lessons.  Greg
calls for a "culture of patching". If incremental change could be adopted in
teaching, teachers could aggregate methods and lesson plans, removing the
massive duplication, and most importantly, making teaching materials that
actually work for students to learn. Greg Wilson asks why open source and
Wikipedia are able to thrive on massive &lt;em&gt;incremental&lt;/em&gt; change, but teaching
is not, a question he hasn't found the answer to.&lt;/p&gt;
&lt;p&gt;My thought on the matter is that unlike writing software or collecting and
presenting facts, pedagogy is very difficult. If I contribute a patch to
an open source project that fixes a bug, I can run the tests to see if my
fix is "correct". If I fix an incorrect fact on Wikipedia, it is less
easy, but I can still cite and check references to make sure it is
correct.  But for teaching, it is very difficult to know what methods work
and what don't, and as Greg pointed out at the beginning of his talk, the
effects of different methods can be very counterintuitive.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The second talk that I recommend is
&lt;a href="http://jakevdp.github.io/"&gt;Jake VanderPlas&lt;/a&gt;'s talk about Frequentism and
Bayesianism.&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;center&gt;&lt;iframe width="560" height="315" src="//www.youtube.com/embed/KhAUfqhLakw" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;&lt;/center&gt;
&lt;p&gt;I won't summarize this talk, as Jake has done a much better job in his blog
(parts
&lt;a href="http://jakevdp.github.io/blog/2014/03/11/frequentism-and-bayesianism-a-practical-intro/"&gt;one&lt;/a&gt;,
&lt;a href="http://jakevdp.github.io/blog/2014/06/06/frequentism-and-bayesianism-2-when-results-differ/"&gt;two&lt;/a&gt;,
&lt;a href="http://jakevdp.github.io/blog/2014/06/12/frequentism-and-bayesianism-3-confidence-credibility/"&gt;three&lt;/a&gt;,
and
&lt;a href="http://jakevdp.github.io/blog/2014/06/14/frequentism-and-bayesianism-4-bayesian-in-python/"&gt;four&lt;/a&gt;). The
best thing is to just watch the talk.  I will just point out that before the
talk, I did not really understand the difference, not being a statistician or
someone who works with statistics regularly, and having seen the talk, I now
feel that I do.  It's a controversial topic, and if you care about the matter,
you should know that Jake is a strong Bayesian, although I felt that he gave
both sides a fair exposition.&lt;/p&gt;
&lt;p&gt;Again, all talks I saw at the conference were good. But those two I felt were
the best. I should also mention here that I myself gave a talk on Conda (more
on that later).&lt;/p&gt;
&lt;h2&gt;The Conference&lt;/h2&gt;
&lt;p&gt;Of course, the talks are only a part of any conference. The best part of SciPy
is the gathering of the community. Each year I meet more new people, as well
as talk with people I already know, but don't get to see outside of SciPy.&lt;/p&gt;
&lt;p&gt;For me, the biggest part of the interactions this year were on Conda and
packaging.  The background is that I have been working full time for Continuum
since January, and I had interned last summer, working primarily on the Conda
package manager and Anaconda, the Python distribution.  This year, some of the
biggest buzz at the conference was about Conda. I'm obviously selection
biased, because people came to me specifically to talk about Conda, but I also
overheard it in other people's conversations, in several of the presentations,
and frankly, the people who did talk to me about Conda were &lt;em&gt;very&lt;/em&gt; excited
about it.  Just like everyone was talking about the IPython Notebook last year
and how it has solved the fundamental problems of sharing and presenting data
analysis, this year, everyone thanked me for my work on Conda and how it has
basically solved the packaging problem, the ubiquitous problem in Python since
people started using it.&lt;/p&gt;
&lt;h3&gt;Conda: The Packaging Problem Solved&lt;/h3&gt;
&lt;p&gt;Here is the talk I gave on Conda:&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;center&gt;&lt;iframe width="560" height="315" src="//www.youtube.com/embed/UaIvrDWrIWM" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;&lt;/center&gt;
&lt;p&gt;I made the claim in my talk that Conda has solved the packaging problem, and
the general feel from people I talked to who are using Conda is that it has.&lt;/p&gt;
&lt;p&gt;I think this slide from my presentation summarizes why Conda solves the
packaging problem.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://asmeurer.github.io/blog/galleries/conda_scipy2014_slide.png" width="500"&gt;&lt;/p&gt;
&lt;p&gt;One of the most amazing things about the scientific Python community, and one
of the things that I think really sets it apart from other Python communities,
is the use of Python alongside other languages, such as C, C++, Fortran, R, or
Julia.  No one language is enough to get the job done for serious scientific
work.  The fundamental brokenness of Python packaging has been that it has
focused too much on Python specific tools and processes.  The
distutils/setuptools/pip/virtualenv stack works great if your code begins and
ends with Python.  Where it falls over is when you want to link against a C
library, compile some Fortran or Cython code, and communicate with other
languages like R and Julia.  By being a system level package manager, which is
fundamentally Python agnostic, Conda is able to deal with all packages
equally, whether that package be a Python package, a C extension which other
packages link against, or Python itself.&lt;/p&gt;
&lt;p&gt;By being truly cross-platform and user installable, Conda is able to reach the
maximal number of users, especially those who have historically been hit by
the packaging problem the hardest:  those who are on Windows or those who do
not have admin rights to install necessary tools to install the packages they
need.&lt;/p&gt;
&lt;p&gt;Finally, Conda installs binaries, not source packages, and its metadata is
entirely static (you do not need to execute arbitrary Python code to capture
the metadata of a package).  These two things remove two of the largest
sources of issues with the existing Python packaging tools, such as compiler
errors, and nonuniformity in metadata standards (there seem to be as many
different ways of writing &lt;code&gt;setup.py&lt;/code&gt; as there are packages on PyPI), by
removing arbitrary code execution from package installation.&lt;/p&gt;
&lt;p&gt;Conda opens up its ecosystem to anybody by making it easy for people to build
their own Conda packages using reproducible Conda recipes.  And
&lt;a href="https://binstar.org/"&gt;Binstar&lt;/a&gt; makes it easy to share those packages.  I'm
very excited about Binstar, as I think it does for packaging what GitHub has
done for open source, i.e., distributes and democratizes it. There are
challenges on how to deal with this, of course. As with any distributed
democratized system, Binstar can be a wild west of packages.  Continuum is
thinking about ways to manage this complexity, while still reaping the
benefits it provides. If you have any thoughts on things that can be done, let
me know in the comments section below.&lt;/p&gt;
&lt;p&gt;Of course, solving the packaging problem and removing it are different
things.  Conda does not make it easier to compile difficult packages.  It only
makes it so that fewer people have to do it.  And there is still work to be
done before Conda really takes over the world.&lt;/p&gt;
&lt;h2&gt;Sprints&lt;/h2&gt;
&lt;p&gt;The conference ended with two days of sprints. I mainly helped people with
Conda packaging.  One key thing that happened is that I worked with Aron
Ahmadia so that HashDist can generate Conda
packages. &lt;a href="http://hashdist.github.io/"&gt;HashDist&lt;/a&gt; is a package compiling
framework that makes it easy to have completely reproducible builds by hashing
all the information that was used to compile a package, and recompiling when
any of that information changes. You can learn more about HashDist by watching
Aron's talk from the conference:&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;center&gt;&lt;iframe width="560" height="315" src="//www.youtube.com/embed/wviHkzk0AkY" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;&lt;/center&gt;
&lt;p&gt;I am now convinced that HashDist is a good solution for people who still want
the control of compiling their own packages. Once HashDist is able to produce
Conda packages, then you can gain the benefits of both worlds: Conda's
powerful package management and environment notion, with HashDist's modular
and reproducible package building framework.&lt;/p&gt;
&lt;h2&gt;Other thoughts&lt;/h2&gt;
&lt;p&gt;The organizers of SciPy did an excellent job this year.  The video crew did
something which I have not seen before, which is that they uploaded the videos
of the talks on the same day that the talks were held. My talk, which was held
right before lunch, was uploaded before the last talk of the day.  Something
that I saw come out of this is that people not attending the conference were
able to watch the talks and take part of the conversation with the conference
attendees, via Twitter and other social media, or by joining the sprints after
the conference.&lt;/p&gt;
&lt;p&gt;The extended three days of talks really took their toll on me. The conference
starts early enough in the morning and the social events after go so late in
the evening that each day of the conference I become a little more sleep
deprived. Usually by two days of tutorials and two days of talks I have hit my
limit, and this year, I really had a hard time making it through that fifth
day. Fortunately for the sprints I was able sleep in a little bit, as it's not
a big deal if you miss the beginning.&lt;/p&gt;
&lt;p&gt;This year the conference organizers made a push for diversity, and it
shows. There were noticeably more women at the conference this year, and not
just insomuch as there were more people at all.&lt;/p&gt;
&lt;p&gt;Finally, I leave you with the greatest lightening talk. Ever.&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;center&gt;&lt;iframe width="560" height="315" src="//www.youtube.com/embed/ln4nE_EVDCg?start=3254" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;&lt;/center&gt;
&lt;!-- LocalWords:  Gede Obinna Nwanna iframe src frameborder allowfullscreen -
--&gt;
&lt;!--  LocalWords:  - VanderPlas 's PyDy 's img Ahmadia
 --&gt;&lt;/div&gt;</description><guid>https://asmeurer.github.io/blog/posts/scipy-2014/</guid><pubDate>Sun, 13 Jul 2014 16:52:27 GMT</pubDate></item><item><title>Moving to GitHub pages with Nikola</title><link>https://asmeurer.github.io/blog/posts/moving-to-github-pages-with-nikola/</link><dc:creator>Aaron Meurer</dc:creator><description>&lt;div&gt;&lt;p&gt;So I've finally decided to move my blog from Wordpress to GitHub pages.  I
highly recommend it if you are technically skilled enough to do it. I was
getting pretty annoyed at Wordpress. It forces you to write your posts in
html (or else using their WYSIWYG editor), the wordpress.com is locked down,
so you can't add any Javascript, their math is stuck in the past rendering png
instead of using MathJax. The list goes on.&lt;/p&gt;
&lt;p&gt;With GitHub pages, I can write my posts in Markdown, and I have full control
over everything. And there is no lock in. If I decide I don't like the
software that is generating the posts, I can easily move to something else,
since the post content itself is all Markdown (or the occasional rst or
IPython notebook if I want to do something that Markdown doesn't support). I
can use MathJax for math (like \( e^{i\pi} + 1 = 0 \)). Wordpress.com
doesn't let you install abtirary Javascript on your blog, so you can't do
things like install MathJax or enable some cool sidebar thing (like a Twitter
feed).&lt;/p&gt;
&lt;h2&gt;Setting up GitHub Pages&lt;/h2&gt;
&lt;p&gt;First, you need to set up GitHub pages. This is a bit confusing, because there
are actually two kinds of GitHub pages, user pages and project pages. User
pages are if you have a repo named &lt;code&gt;username.github.io&lt;/code&gt; (or &lt;code&gt;.com&lt;/code&gt;). The pages
are served from the &lt;code&gt;master&lt;/code&gt; branch.&lt;/p&gt;
&lt;p&gt;For project pages, you add a &lt;code&gt;gh-pages&lt;/code&gt; branch to any one of your projects,
and GitHub hosts the content automatically at
&lt;code&gt;username.github.io/projectname&lt;/code&gt;. I originally had my blog content at
&lt;code&gt;asmeurer.github.io&lt;/code&gt;, but I didn't like that I had to do everything in master,
both the generated and original content. So instead I created a repo called
&lt;code&gt;blog&lt;/code&gt;. I have my content in the &lt;code&gt;master&lt;/code&gt; branch and the generated pages in
the &lt;code&gt;gh-pages&lt;/code&gt; branch (more on this later). At my
&lt;a href="https://github.com/asmeurer/asmeurer.github.com"&gt;&lt;code&gt;asmeurer.github.com&lt;/code&gt;&lt;/a&gt; repo,
I just have for now a basic redirect to the blog. In the future, I may want to
put additional, non-blog content on the website, and it would go there (or in
a separate project repo with its own &lt;code&gt;gh-pages&lt;/code&gt; branch).&lt;/p&gt;
&lt;h2&gt;Nikola&lt;/h2&gt;
&lt;p&gt;I had initially planned on using
&lt;a href="http://blog.getpelican.com/"&gt;Pelican&lt;/a&gt;. However, I got stalled on the
Wordpress import. I like that Pelican is written in Python, but I was not too
keen on their abrasive
&lt;a href="https://github.com/getpelican/pelican/blob/master/LICENSE"&gt;license&lt;/a&gt;. Frankly,
I shouldn't say too many bad things about Pelican because I never really tried
that hard with it.&lt;/p&gt;
&lt;p&gt;I have decided to try &lt;a href="http://getnikola.com/"&gt;Nikola&lt;/a&gt; instead. It's also
written in Python. It has a very nice
&lt;a href="https://github.com/getnikola/nikola/blob/master/LICENSE.txt"&gt;license&lt;/a&gt;. I like
the philosophy of the &lt;a href="http://getnikola.com/handbook.html"&gt;manual&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;DON'T READ THIS MANUAL. IF YOU NEED TO READ IT I FAILED, JUST USE THE THING.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;I've also discovered that the
&lt;a href="https://groups.google.com/forum/#%21forum/nikola-discuss"&gt;Nikola community&lt;/a&gt; is
&lt;em&gt;very&lt;/em&gt; nice. And of course, even if Nikola ends up not being for me, it will
be easy to switch, because my actual content is just some Markdown files that
I own.&lt;/p&gt;
&lt;h3&gt;Getting started&lt;/h3&gt;
&lt;p&gt;Getting started with Nikola is pretty easy. First, you need to install it. It
has a &lt;em&gt;ton&lt;/em&gt; of dependencies (fortunately all Python, so it won't be that
hard). In addition to the ones in the requirements.txt, you should also
install &lt;code&gt;markdown&lt;/code&gt; and &lt;code&gt;webassets&lt;/code&gt;. While using &lt;code&gt;nikola&lt;/code&gt;, it will tell you if
you don't have something installed that you should, so if you see that, just
install what it tells you to.  If you use &lt;code&gt;conda&lt;/code&gt; and Mac OS X, I have
uploaded all the dependencies to my &lt;a href="https://binstar.org/asmeurer/"&gt;Binstar&lt;/a&gt;,
so you can just &lt;code&gt;conda install -c asmeurer nikola&lt;/code&gt;. Oh and don't worry, Nikola
and its dependencies fully support Python 3 (I wouldn't be using it if they
didn't).&lt;/p&gt;
&lt;p&gt;Then you just run the commands from
http://getnikola.com/handbook.html#all-you-need-to-know.&lt;/p&gt;
&lt;p&gt;One thing that doesn't tell you is that after you init the site, you should
walk through &lt;code&gt;conf.py&lt;/code&gt; and change the settings to your liking.&lt;/p&gt;
&lt;p&gt;Another trick not there is that you can add&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;eval "`nikola tabcompletion`"
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;to your Bash profile to get tab completion.&lt;/p&gt;
&lt;h3&gt;Tricks&lt;/h3&gt;
&lt;p&gt;Here are some useful tricks:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;To enable MathJax, you have to type &lt;code&gt;mathjax&lt;/code&gt; in a line by itself in the
metadata file. There are some bugs right now, but ideally you could do inline
math with &lt;code&gt;$math$&lt;/code&gt; and display math with &lt;code&gt;$$math$$&lt;/code&gt;. &lt;code&gt;$math$&lt;/code&gt; doesn't work
currently, but you can do &lt;code&gt;\\(math\\)&lt;/code&gt; (both &lt;code&gt;\&lt;/code&gt;s are required, although this
is likely a bug). You can do &lt;code&gt;\\[math\\]&lt;/code&gt; for display math.  Here are some
examples. Inline: \( \sin ^2{x} + \cos^2{x} = 1\). Display: $$ e^{i\pi} + 1 = 0 .$$&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Your one-stop command when blogging is &lt;code&gt;nikola auto&lt;/code&gt;. This requires
&lt;code&gt;livereload&lt;/code&gt;. This will serve the blog on localhost, and automatically
rebuild it when any change is made (and I really mean &lt;em&gt;any&lt;/em&gt; change: it can
even detect when you change Nikola itself).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;I have the following in my conf.py to deploy:&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;DEPLOY_COMMANDS = [
    "git checkout gh-pages",
    "rsync -rPv --delete-after --exclude old_blog --exclude .git --exclude .gitignore --exclude cache/ --exclude .doit.db.db output/ .",
    "git add -A",
    "git commit -a -m 'Updating blog content'",
    "git push",
    "git checkout master",
]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;WARNING: These commands are dangerous. If you don't properly exclude things
like &lt;code&gt;.git&lt;/code&gt;, you will wipe your entire git history. I &lt;em&gt;highly&lt;/em&gt; recommend
committing everything and pushing to GitHub before deploying.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Use&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;_site/
*.pyc
.DS_Store
.doit.db.db
cache/
output/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;for your &lt;code&gt;.gitignore&lt;/code&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Despite what it says on the Nikola page, be sure to read the docs, because
there are a lot of cool features you won't know about unless you read about
them. Also be sure to read through &lt;code&gt;conf.py&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Wordpress import&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;This is something that I am still figuring out. You can see the progress at
&lt;a href="http://asmeurer.github.io/blog/old_blog"&gt;http://asmeurer.github.io/blog/old_blog&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Importing from Wordpress is pretty easy actually (at least in theory). First
you need to go to the Wordpress site dashboard and go to "Export" from the
"Tools" menu. From here you can download an XML file with all your
content. Then just do&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;nikola import_wordpress export_file.xml
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that the current version of Nikola as of this writing (6.3.0) doesn't do
this right, so you'll need to use the
&lt;a href="https://github.com/getnikola/nikola"&gt;git master&lt;/a&gt;. There are some issues with
the import, since Wordpress has its own markup that it doesn't know everything
about, so you may need to go in and fix things. Or report them as bugs to
Nikola and reimport when they are fixed.&lt;/p&gt;
&lt;p&gt;You'll need to go through the posts and make sure that they are rendered
correctly (this is one reason I haven't finished doing it yet).&lt;/p&gt;
&lt;p&gt;For comments, you first need to create a Disqus account, and enable it in your
conf.py. You should then upload the xml file that you exported from Wordpress
to Disqus. At this point, the comments should just work, because Nikola sets
the Disqus url for the imported comments to the old Wordpress url (look at the
Disqus section of one of the built pages).&lt;/p&gt;
&lt;p&gt;I don't know how to automatically backlink from Wordpress back to
Nikola. Maybe I should just automatically generate some links and paste them
in manually.&lt;/p&gt;&lt;/div&gt;</description><category>mathjax</category><guid>https://asmeurer.github.io/blog/posts/moving-to-github-pages-with-nikola/</guid><pubDate>Sun, 09 Feb 2014 23:19:18 GMT</pubDate></item></channel></rss>