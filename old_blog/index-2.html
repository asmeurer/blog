<!DOCTYPE html><html lang="en">
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="My blog on my work on SymPy and other fun stuff.">
    <meta name="author" content="Aaron Meurer">
    <title>Aaron Meurer's SymPy Blog (old posts, page 2) | Aaron Meurer's SymPy Blog</title>
    
            <link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
    <link rel="canonical" href="http://asmeurersympy.wordpress.com/index-2.html">
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js" type="text/javascript"></script>
    <![endif]-->
            <link rel="alternate" type="application/rss+xml" title="RSS" href="rss.xml">

    
    
    
</head>
<body>
<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="navbar-header">
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="http://asmeurersympy.wordpress.com/">Aaron Meurer's SymPy Blog</a>
    </div>
    <div class="collapse navbar-collapse navbar-ex1-collapse">
        <ul class="nav navbar-nav">
            
                <li><a href="archive.html">Archives</a>
                </li><li><a href="categories/index.html">Tags</a>
                </li><li><a href="rss.xml">RSS</a>

        </li></ul>

        <ul class="nav navbar-nav navbar-right">
            
            
        </ul>
    </div><!-- /.navbar-collapse -->
</nav>

<!-- End of Menubar -->

<div class="container">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
        <article class="postbox h-entry post-text">
        <h1 class="p-name"><a href="posts/2009/08/12/testing-implicit-solutions-to-odes.html" class="u-url">Testing implicit solutions to ODEs</a>
        <small>  
             Posted: <time class="published dt-published" datetime="2009-08-12T21:27:21+00:00">2009-08-12 21:27</time>
        </small></h1>
        <hr>
        <div class="e-content">
        <div><p></p><p>So, the hard deadline for GSoC it Monday, so this will probably be my last post until then (I am very busy trying to finish up the ode module by then).  But this is one of those things that you just have to blog about.</p>
<p>So I have this checksol function in test_ode.py that attempts to check it the solutions to odes are valid or not.  It was a relic of the old ode module.  For that, it would just substitute the solution into the ode and see if it simplified to 0.  That is what it still does, if the solution is solved for f(x) (the function for all of my ode tests).  But if the solution is implicit in f, either because solve() is not good enough to solve it or because it cannot be solved, then that method obviously does not work.  So what I was trying to do is what my textbook suggested.  Take the derivative of the solution implicitly n times, where n is the order of the ode, and see if that is equal to the ode.  Basically, I was subtracting the ode from it and seeing if it reduced to 0.</p>
<p>However, it wasn't really working at all for most of my implicit solutions, even the really simple ones.  I ended up XFAILing most of my implicit checksol tests.  I think every single <a href="http://asmeurersympy.wordpress.com/2009/05/31/first-order-differential-equations-with-homogeneous-coefficients/">homogeneous coefficients</a> had an implicit solution, and none of them were working with checksol().  </p>
<p>So I started to ask around on IRC to see if anyone had any better ideas for testing these.  Ondrej couldn't think of anything.  Luke and Chris worked on an example that I gave them, and it seemed to be that it <em>wasn't</em> correct (which I didn't believe for a second, because the solution was straight out of my text, and both homogeneous coefficients integrals produced that same solution).  It turns out that we were mixing up $latex \log{\frac{y}{x}}$ and $latex \log{\frac{x}{y}}$ terms.  One of those appeared in the ode and the other appeared in the solution (the ode was $latex y dx  + x\log{\frac{y}{x}}dy - 2x dy = 0$ and the solution is $latex \frac{y}{1 + \log{\frac{x}{y}}}=C$, <a href="http://books.google.com.np/books?id=29utVed7QMIC&amp;lpg=PA24&amp;ots=uxLSUKt_3P&amp;dq=testing%20implicit%20solutions%20to%20ode&amp;hl=en&amp;pg=PA61#v=onepage&amp;q=&amp;f=false">number 9 from my odes text, pg. 61</a>.  </p>
<p>So Chris had a novel idea.  For 1st order odes, you can take the derivative of the solution and solve for $latex \frac{dy}{dx}$, which will always be possible, because differentiation is a linear operator.  Then substitute that into the original ode, and it will reduce.  </p>
<p>So we were talking about this on IRC later, and I had an epiphany as to why my original method wasn't working.  After trying it manually on an ode, I found that I had to multiply through the solution's derivative by $latex \frac{x}{f(x)}$ to make it equal to the ode.  Then, that reminded me of an important solution method that I didn't have time to implement this summer: integrating factors.  I remember that my textbook had <a href="http://books.google.com.np/books?id=29utVed7QMIC&amp;lpg=PA24&amp;ots=uxLSUKt_3P&amp;dq=testing%20implicit%20solutions%20to%20ode&amp;hl=en&amp;pg=PA83#v=onepage&amp;q=&amp;f=false">mentioned</a> that there is a theorem that states that every 1st order ODE that is linear in the derivative has a unique integrating factor that makes it exact.  And I realized, the derivative of the solution will be equal to the ODE if and only if the ODE is exact.  I checked my exact tests and verified my hunch.  I had to XFAIL all of my implicit homogeneous coefficients solutions, but all of my exact checksols were working just fine.  </p>
<p>So I refactored my checksol function to do this, and it now can check almost every one of my failing checksols.  The exceptions are some where trigsimp() cannot simplify the solution to 0 (we have a poor trigsimp), a second order solution (the above trick only works on 1st order odes, I believe), and some other simplification problems. </p>
<p>The only down side to this new routine is that it is kind of slow (because of the simplification).  I am going to have to skip a test of only 6 solutions because it takes 24 seconds to complete.  </p></div>
        </div>
            
        
    <p>
        <a href="posts/2009/08/12/testing-implicit-solutions-to-odes.html#disqus_thread" data-disqus-identifier="cache/posts/2009/08/12/testing-implicit-solutions-to-odes.html">Comments</a>


        </p></article>
        <article class="postbox h-entry post-text">
        <h1 class="p-name"><a href="posts/2009/08/10/homogeneous-coefficients-corner-case.html" class="u-url">Homogeneous coefficients corner case</a>
        <small>  
             Posted: <time class="published dt-published" datetime="2009-08-10T17:30:22+00:00">2009-08-10 17:30</time>
        </small></h1>
        <hr>
        <div class="e-content">
        <div><p></p><p>Before I started the program, I implemented Bernoulli equations.  But the general solution to Bernoulli equations involves raising something to the power of $latex \frac{1}{1-n}$, where n is the power of the dependent term (see the <a href="http://en.wikipedia.org/wiki/Special:Search?search=bernoulli%20differential%20equation&amp;go=Go">Wikipedia page</a> for more info).  This works great, as I soon discovered, unless n == 1.  Then you get something to the power of $latex \infty$.  So I had to go in and remove the corner case.</p>
<p>So you think that after that I would have been more careful after that about checking that if general solution that divides by something I would test to see if that something is not zero before returning it as a solution.</p>
<p>Well, as I was just trying to implement some separable equation tests, I was going through the exercises of my ode text as I usually do for tests, and I came across $latex xy' - y = 0$.  If you recall, this equation also has coefficients that homogeneous of the same order (1). From the general solution to homogeneous coefficients, you would plug it into $latex \int{\frac{dx}{x}}=\int{\frac{-Q(1,u)du}{P(1,u)+uQ(1,u)}}+C$ where $latex u = \frac{y}{x}$ or $latex \int{\frac{dy}{y}}=\int{\frac{-P(u,1)du}{uP(u,1)+Q(u,1)}}+C$ where $latex u = \frac{x}{y}$ (here, P and Q are from the general form $latex P(x,y)dx+Q(x,y)dy=0$).  Well, it turns out that if you plug the coefficients from my example into those equations, the denominator will become 0 for each one.  So I (obviously) need to check for that $latex P(1,u)+uQ(1,u)$ and  $latex uP(u,1)+Q(u,1)$ are not 0 before running the homogeneous coefficients solver on a differential equation.</p></div>
        </div>
            
        
    <p>
        <a href="posts/2009/08/10/homogeneous-coefficients-corner-case.html#disqus_thread" data-disqus-identifier="cache/posts/2009/08/10/homogeneous-coefficients-corner-case.html">Comments</a>


        </p></article>
        <article class="postbox h-entry post-text">
        <h1 class="p-name"><a href="posts/2009/08/01/variation-of-parameters-and-more.html" class="u-url">Variation of Parameters and More</a>
        <small>  
             Posted: <time class="published dt-published" datetime="2009-08-01T17:39:48+00:00">2009-08-01 17:39</time>
        </small></h1>
        <hr>
        <div class="e-content">
        <div><p></p><p>Well, the last time I posted a project update, I had resigned myself to writing a constant simplifying function and putting the Constant class on the shelf.  Well, just as I suspected, it was hell writing it, but I eventually got it working.  Already, what I have in dsolve() benefits from it.  I had many solutions with things like $latex \frac{x}{C_1}$ or $latex -C_1x$ in them, and they are now automatically reduced to just $latex C_1x$.  Of course, the disadvantage to this, as I mentioned in the other post, is that it will only simplify once.  Also, I wrote the function very specifically for expressions returned by dsolve.  It only works, for example, with constants named sequentially like C1, C2, C3 and so on.  Even with making it specialized, it was still hell to write.  I was also able to get it to renumber the constants, so something like <code>C2<em>sin(x) + C1</em>cos(x)</code> would get transfered to <code>C1<em>sin(x) + C2</em>cos(x)</code>.  It uses <code>Basic._compare_pretty()</code> (thanks to Andy for that tip), so it will always number the constants in the order they are printed.  </p>
<p>Once I got that working, it was just little work to finish up what I had already started with solving general linear homogeneous odes ($latex a_ny^{(n)} + a_{n-1}y^{(n-1)} + \dots + a_2y'' + a_1y' + a_0y = 0$ with $latex a_i$ constant for all $latex i$).  Solving these equations is easy.  You just set up a polynomial of the form $latex a_nm^n + a_{n-1}m^{n-1} + \cdots + a_2m^2 + a_1m + a_0 = 0$ and find the roots of it.  Then you plug the roots into an exponential times $latex x^i$ for i from 1 to the multiplicity of the root  (as in $latex Cx^ie^{root \cdot x}$).  You usually expand the real and complex parts of the root using Euler's Formula, and, once you simplify the constants, you get something like $latex x^ie^{realpart \cdot x}(C_1\sin{(impart \cdot x)} + C_2\cos{(impart \cdot x)})$ for each i from 1 to the multiplicity of the root.  Anyway, with the new constantsimp() routine, I was able to set this whole thing up as one step, because if the imaginary part is 0, then the two constants will be simplified into each other.  Also, SymPy has some good polynomial solving, so I didn't have any problems there.  I even made good use of the collect() function to factor out common terms, so you get something like $latex (C_1 + C_2x)e^{x}$ instead of $latex C_1e^{x} + C_2xe^{x}$, which for larger order solutions, can make the solution much easier to read (compare for example, $latex ((C_1 + C_2x)\sin{x} + (C_3 + C_4x)\cos{x})e^{x}$ with the expanded form, $latex C_1e^{x}\sin{x} + C_2xe^{x}\sin{x} + C_3\cos{x}e^{x} + C_4x\cos{x}{e^x}$ as the solution to $latex {\frac {d^{4}}{d{x}^{4}}}f \left( x \right) -4\,{\frac {d^{3}}{d{x}^{3}}}f \left( x \right) +8\,{\frac {d^{2}}{d{x}^{2}}}f \left( x \right) -8\,{\frac {d}{dx}}f \left( x \right) +4\,f \left( x \right) =0$).  </p>
<p>I entered all 30 examples from the relevant chapter of my text (Ordinary Differential Equations by Morris Tenenbaum and Harry Pollard), and the whole thing runs in under 2 seconds on my machine.  So it is fast, though that is mostly due to fast polynomial solving in SymPy.  </p>
<p>So once I got that working well, I started implementing variation of parameters, which is a general method for solving all equations of form $latex a_ny^{(n)} + a_{n-1}y^{(n-1)} + \dots + a_2y'' + a_1y' + a_0y = F(x)$.  The method will set up an integral to represent the particular solution to any equation of this form, assuming that you have all $latex n$ linearly independent solutions to the homogeneous equation $latex a_ny^{(n)} + a_{n-1}y^{(n-1)} + \dots + a_2y'' + a_1y' + a_0y = 0$.  The coefficients $latex a_i$ do not even have to be constant for this method to work, although they do have to be in my implantation because otherwise it will not be able to find general solution to the homogeneous equation.  </p>
<p>So, aside from doing my GSoC project this summer, I am also learning Linear Algebra, because I could not fit it in to my schedule next semester and I need to know it for my Knot Theory class.  It turns out that it was very useful in learning the method of variation of parameters.  I will explain how the method works below, but first I have a little rant.  </p>
<p>Why is the Wikipedia article on <a href="http://en.wikipedia.org/wiki/Variation_of_parameters">variation of parameters</a> the only website anywhere that covers variation of parameters in the general case?  Every other site that I could find only covers 2nd order equations, which I understand is what is taught in most courses because applying it to anything higher can be tedious and deriving the nth order case requires knowledge of Cramer's Rule, which many students may not know.  But you would think that there would at least be sites that discuss what I am about to discuss below, namely, applying it to the general case of an nth order inhomogeneous linear ode.  Even the <a href="http://mathworld.wolfram.com/VariationofParameters.html">Wolphram MathWorld article</a> only explains the derivation for a second order linear ODE, mentioning at the bottom that it can be applied to nth order linear ODEs.  I did find a website called <a href="http://planetmath.org/encyclopedia/VariationOfParameters.html">Planet Math</a> that covers the general case, but it wasn't on the top of the Google results list and took some digging to find.  It also has problems of its own, like being on a very slow server and some of the LaTeX on the page not rendering among them. </p>
<p>This partially annoys me because the Wikipedia article is not very well written.  You have to read through it several times to understand the derivation (I will try to be better below).  The Planet Math site is a little better, but like I said, it took some digging to find, and I actually found it after I had written up half of this post already.  </p>
<p>But it is also part of a larger attitude that I am finding more and more of where anything that is not likely to be directly applied is not worth knowing and thus not worth teaching.  Sure, it is not likely that any person doing hand calculations will ever attempt variation of parameters on an ode of order higher than 2 or 3, but that is what computer algebra systems like SymPy are for.  Unfortunately, it seems that they are also in a large part for allowing you to not know how or why something mathematically is true.  What difference does it make if variation of parameters can be applied to a 5th order ODE if I have to use Maple to do actually do it anyway.  As long as the makers of Maple know how to apply variation of parameters to a nth order ODE, I can get along just fine.  At least with SymPy, the source is freely available, so anyone who does desire to know how things are working can easily see.  Anyway, I am done ranting now, so if you were skipping that part, this would be the point to start reading again.</p>
<p>So you have your linear inhomogeneous ODE: $latex a_ny^{(n)} + a_{n-1}y^{(n-1)} + \dots + a_2y'' + a_1y' + a_0y = F(x)$.  $latex a_n$ cannot be zero (otherwise it would be a n-1 order ODE), so we can and should divide through by it.  Lets pretend that we already did that, and just use the same letters.  Also, I will rewrite $latex a_n$ as $latex a_n(x)$ to emphasize that the coefficients do not have to be constants for this to work.  So you have your linear inhomogeneous ODE: $latex y^{(n)} + a_{n-1}(x)y^{(n-1)} + \dots + a_2(x)y'' + a_1(x)y' + a_0(x)y = F(x)$.  So, as I mentioned above, we need n linearly independent solutions to the homogeneous equation $latex y^{(n)} + a_{n-1}(x)y^{(n-1)} + \dots + a_2(x)y'' + a_1(x)y' + a_0(x)y = 0$ to use this method.  Let us call those solutions $latex y_1(x), y_2(x), \dots, y_n(x)$.  Now let us write our particular solution as $latex y_p(x) = c_1(x)y_1(x) + c_2(x)y_2(x) + \dots + c_n(x)y_n(x)$.  Now, if we substitute our particular solution in to the left hand side of our ODE, we should get $latex F(x)$ back.  So we have $latex (y_p)^{(n)} + a_{n-1}(x)(y_p)^{(n-1)} + \dots + a_2(x)y_p'' + a_1(x)y_p' + a_0(x)y_p =$ $latex F(x)$.  Now, let me rewrite $latex y_p$ as a summation to help keep things from getting too messy.  I am also going to write $latex c_i$ instead of $latex c_i(x)$ on terms for additional sanity.  Every variable is a function of x.  $latex y_p(x) = \sum_{i=1}^{n} c_i y_i$.  The particular solution should satisfy the condition of the ODE, so</p>
<p>$latex y_p^{(n)} + a_{n-1}y_p^{(n-1)} + \dots + a_2y_p'' + a_1y_p' + a_0y_p = F(x)$.</p>
<p>$latex (\sum_{i=1}^{n} c_i y_i)^{(n)} + a_{n-1}(\sum_{i=1}^{n} c_i y_i)^{(n-1)} + \dots + a_2(\sum_{i=1}^{n} c_i y_i)^{(2)} + $</p>
<p>$latex a_1(\sum_{i=1}^{n} c_i y_i)^{(1)} + a_0\sum_{i=1}^{n} c_i y_i = F(x)$.</p>
<p>Now, if we apply the product rule to this, things will get ugly really fast, because we have to apply the product rule on each term as many times as the order of that term (the first term would have to be applied n times, the second, n-1 times, and so on).  But there is a trick that we can use.  In the homogeneous case, there is no particular solution, so in that case the $latex c_i$ terms must all vanish identically because the solutions are linearly independent of one another.  Thus, if we plug the particular solution into the homogeneous case, we get</p>
<p>$latex (\sum_{i=1}^{n} c_i y_i)^{(n)} + a_{n-1}(\sum_{i=1}^{n} c_i y_i)^{(n-1)} + \dots + a_2(\sum_{i=1}^{n} c_i y_i)^{(2)} + $</p>
<p>$latex a_1(\sum_{i=1}^{n} c_i y_i)^{(1)} + a_0\sum_{i=1}^{n} c_i y_i = 0$.</p>
<p>We already know that if we plug the $latex y_i$ terms in individually of the $latex c_i$ terms, that the expression will vanish identically because the $latex y_i$ terms are solutions to the homogeneous equation.  The product rule on each term will be evaluated according to the <a href="http://en.wikipedia.org/wiki/Leibniz_rule_(generalized_product_rule)">Leibniz Rule</a>, which is that $latex (c_i \cdot f_i)^{(n)}=\sum_{k=0}^n {n \choose k} c_i^{(k)} y_i(x)^{(n-k)}$.  Now the $latex c_i y_i^{(n)}$ terms will vanish because we can factor out a $latex c_i$ and they will be exactly the homogeneous solution.  Because the expression is identically equal to zero, the remaining terms must vanish as well.  If we assume that each $latex \sum_{i=1}^n c_i' y_i^{(j)}=0$ for each j from 0 to n-2, then this will take care of this; the terms with higher derivatives on $latex c_i$ will also be 0, if this is true, then we do not need them for our derivation.  In other words, </p>
<p>$latex  c_1' y_1  + c_2' y_2 + \cdots + c_n' y_n = 0 $</p>
<p>$latex c_n' y_1' + c_n' y_2' + \cdots + c_n' y_n' = 0 $</p>
<p>$latex \vdots $</p>
<p>$latex c_n' y_1^{(n-2)} + c_n' y_2^{(n-2)} + \cdots + c_n' y_n^{(n-2)} = 0$.</p>
<p>So, turning back to our original ODE with the particular solution substituted in, we have</p>
<p>$latex (\sum_{i=1}^{n} c_i y_i)^{(n)} + a_{n-1}(\sum_{i=1}^{n} c_i y_i)^{(n-1)} + \dots + a_2(\sum_{i=1}^{n} c_i y_i)^{(2)} + $</p>
<p>$latex a_1(\sum_{i=1}^{n} c_i y_i)^{(1)} + a_0\sum_{i=1}^{n} c_i y_i = F(x)$.</p>
<p>But we know that most of the terms of this will vanish, from our assumption above.  If we remove those terms, what remains is $latex \sum_{i=1}^{n} c_i' y_i^{(n-1)} = F(x)$.  So this is where it is nice that I learned <a href="http://en.wikipedia.org/wiki/Cramer%27s_rule">Cramer's Rule</a> literally days before learning how to do Variation of Parameters in the general case.  We have a system of n equations (the n-1 from above, plus the one we just derived), of n unknowns (the $latex c_i$ terms).  The determinant that we use here is used often enough to warrant a name: the <a href="http://en.wikipedia.org/wiki/Wronskian">Wronskian</a>.  We have that $latex c_i' = \frac{W_i(x)}{W(x)}$, or $latex c_i = \int \frac{W_i(x)}{W(x)}$, where $latex W_i(x)$ is the Wronskian of the fundamental system with the ith column replaced with $latex \begin{bmatrix} 0 \ 0 \ \vdots \ 0 \ F(x) \end{bmatrix}$.  So we finally have $latex y_p = \sum_{i=1}^n \int \frac{W_i(x)}{W(x)} y_i$.  </p>
<p>Well, that's the theory, but as always here, that is only half of the story.  A Wronskian function is already implemented in SymPy, and finding $latex W_i(x)$ simply amounts to $latex F(x)$ times the Wronskian of the system without the ith equation, all times $latex (-1)^i$.  So implementing it was easy enough.  But it soon became clear that there would be some problems with this method.  Sometimes, the SymPy would return a really simple Wronskian, something like $latex -4e^{2x}$, but other times, it would return something crazy.  For example, consider the expression that I reported in <a href="http://code.google.com/p/sympy/issues/detail?id=1562">SymPy issue 1562</a>.  The expression is (thanks to SymPy's <code>latex()</code> command, no thanks to WordPress's stupid auto line breaks that have forced me to upload my own image.  If it wasn't such a pain, I would do it for every equation, because it looks much nicer.):</p>
<p><img src="2009/08/crazy-trig-wronskian-sympy.png" alt="Crazy Trig Wronskian (SymPy)" title="Crazy Trig Wronskian (SymPy)" width="450" height="78" class="alignnone size-full wp-image-240">.</p>
<p>This is the Wronskian, as calculated by SymPy's <code>wronskian()</code> function, of </p>
<p>$latex \begin{bmatrix}x \sin{x}, &amp; \sin{x}, &amp; 1, &amp; x \cos{x}, &amp; \cos{x}\end{bmatrix}$, which is the set of linearly independent solutions to the ODE $latex {\frac {d^{5}}{d{x}^{5}}}f \left( x \right) +2\,{\frac {d^{3}}{d{x}^{3}}}f \left( x \right) +{\frac {d}{dx}}f \left( x \right) -1$.  Well, the problem here is that, as verified by Maple, that complex Wronskian above is identically equal to $latex -4$.  SymPy's <code>simplify()</code> and <code>trigsimp()</code> functions are not advanced enough to handle it.  It turns out that in this case, the problem is that SymPy's <code>cancel()</code> and <code>factor()</code> routines do not work unless the expression has only symbols in it, and that expression requires you to cancel and factor to find the $latex \cos^2{x} + \sin^2{x}$ (see the issue page for more information on this).  Unfortunately, SymPy's <code>integrate()</code> cannot handle that unsimplified expression in the denominator of something, as you could imagine, and it seems like almost every time that sin's and cos's are part of the solution to the homogeneous equation, the Wronskian becomes too difficult for SymPy to simplify.  So, while I was hoping to slip along with only variation of parameters, which technically solves every linear inhomogeneous ODE, it looks like I am going to have to implement the method of undetermined coefficients.  Variation of parameters will still be useful, as undetermined coefficients only works if the expression on the right hand side of the equation, $latex F(x)$ has a finite set of linearly independent derivatives (such as sin, cos, exp, polynomial terms, and combinations of them (I'll talk more about this whenever I implement it).  </p>
<p>The good news here is that I discovered that I was wrong.  I had previously believed that among the second order special cases were cases that could only be handled by variation of parameters or undetermined coefficients, but it turns out I was wrong.  All that was implemented were the homogeneous cases for second order linear with constant coefficients.  In addition to this, there was one very special case ODE that Ondrej had implemented for an example (examples/advanced/relativity.py).  The ODE is</p>
<p>$latex -2({\frac{d}{dx}}f(x)){e^{-f(x)}}+x({\frac{d}{dx}}f(x))^{2}{e^{-f(x)}}-x({\frac{d^{2}}{d{x}^{2}}}f(x)){e^{-f(x)}}$, which is the second derivative of $latex xe^{-f(x)}$ with respect to x.  According to the example file, it is know as Einstein's equations.  Maple has a nice <code>odeadvisor()</code> function similar to the <code>classify_ode()</code> function I am writing for SymPy that tells you all of the different ways that an ODE can be solved. So, I plugged that ODE into it and got a few possible methods out that I could potentially implement in SymPy to maintain compatibility with the example equation.  The chief one is that the lowest order of f in the ODE is 1 (assuming you divide out the $latex e^{-f(x)}$ term, which is perfectly reasonable as that term will never be 0. You can then make the substitution $latex u = f'(x)$, and you will reduce the order of the ODE to first order, which in this case would be a Bernoulli equation, the first thing that I ever implemented in SymPy.  </p>
<p>But I didn't do that.  Reduction of order methods would be great to have for <code>dsolve()</code>, but that is a project for another summer.  Aside from that method, Maple's <code>odeadvisor()</code> also told me that it was a Liouville ODE.  I had never heard of that method, and neither it seems has Wikipedia or "Uncle Google" (as Ondrej calls it).  Fortunately, Maple's Documentation has a nice page for each type of ODE returned by <code>odeadvisor()</code>, so I was able to learn the method. The method relies on Lie Symmetries and exact second order equations, neither of which I am actually familiar with, so I will not attempt to prove anything here.  Suffice it to say that if an ODE has the form </p>
<p>$latex {\frac{d^{2}}{d{x}^{2}}}y(x)+g(y(x))({\frac{d}{dx}}y(x))^{2}+f(x){\frac{d}{dx}}y(x)=0$, then the solution to the ODE is</p>
<p>$latex \int^{y(x)}{e^{\int g(a){da}}}{da}+C1\int{e^{-\int f(x){dx}}}{dx}+C2=0$</p>
<p>You could probably verify this by substituting the solution into the original ODE.  See the <a href="http://www.maplesoft.com/support/help/view.aspx?path=odeadvisor/Liouville">Maple Documentation page on Liouville ODEs</a>, as well as the <a href="http://eric.ed.gov:80/ERICWebPortal/custom/portlets/recordDetails/detailmini.jsp?_nfpb=true&amp;_&amp;ERICExtSearch_SearchValue_0=ED089982&amp;ERICExtSearch_SearchType_0=no&amp;accno=ED089982">paper they reference</a> (Goldstein and Braun, "Advanced Methods for the Solution of Differential Equations", see pg. 98).  </p>
<p>The solution is very straight forward--as much so as first order linear or Bernoulli equations, so it was a cinch to implement it.  It looks like quite a few differential equations generated by doing $latex F''(y(x), x)$ for some function or x and y $latex F(y(x), x)$ generates equations of that type, so it could be actually useful for solving other things.  </p>
<p>Before I sign off, I just want to mention one other thing that I implemented.  I wanted my linear homogeneous constant coefficient ODE solver to be able to handle ODEs for which SymPy can't solve the characteristic equation, for whatever reason.  SymPy has <code>RootOf()</code> objects similar to Maple that let you represent the roots of a polynomial without actually solving it, or even being able to solve it, but a you can only use RootOf's if you know that none of the roots are repeated.  Otherwise, you would have to know which terms require an additional $latex x^i$ to preserve linear independence.  Well, it turns out that there is a way to tell if a polynomial has repeated roots without solving for them.  There is a number associated with every polynomial of one variable called the <a href="http://en.wikipedia.org/wiki/Discriminant">discriminant</a>.  For example, the discriminant of the common quadratic polynomial $latex ax^2 + bx + c$ is the term under the square root of the famous solution $latex b^2 - 4ac$.  It is clear that a quadratic has repeated roots if and only if the discriminant is 0.  Well, the same is true for the discriminant of any polynomial.  I am not highly familiar with this (ask me again after I have taken my abstract algebra class next semester), but apparently there is something called the resultant, which is the product of the differences of roots between two polynomials and which can also be calculated without explicitly finding the roots of the polynomials.  Clearly, this will be 0 if and only if the two polynomials share a root.  So the discriminant is built from the fact that a polynomial has a repeated root iff it shares a root with its resultant.  So it is basically the resultant of a polynomial and its derativave, times an extra factor.  It is 0 if and only if the polynomial has a repeated root.  </p>
<p>Fortunately, SymPy's excelent Polys module already had resultants implemented (quite efficiently too, I might add), so it was easy to implement the discriminant.  I added it as <a href="http://code.google.com/p/sympy/issues/detail?id=1555&amp;q=discriminant">issue 1555</a>.  If you are a SymPy developer and you have somehow managed to make yourself read this far (bless your heart), please review that patch.  </p>
<p>Well, this has turned out to be one hella long blog post.  But what can I say.  You don't have to read this thing (except for possibly my mentor.  Sorry Andy).  And I haven't been quite updating weekly like I am supposed to be, so this compensates.  If you happened upon this blog post because, like me, you were looking for a general treatment of variation of parameters, I hope you found my little write up helpful.  And if you did, and you now understand it, could you go ahead and improve the Wikipedia article.  I'm not up to it?  </p></div>
        </div>
            
        
    <p>
        <a href="posts/2009/08/01/variation-of-parameters-and-more.html#disqus_thread" data-disqus-identifier="cache/posts/2009/08/01/variation-of-parameters-and-more.html">Comments</a>


        </p></article>
        <article class="postbox h-entry post-text">
        <h1 class="p-name"><a href="posts/2009/07/20/modifying-a-list-while-looping-through-it-in-python.html" class="u-url">Modifying a list while looping through it in Python</a>
        <small>  
             Posted: <time class="published dt-published" datetime="2009-07-20T06:35:45+00:00">2009-07-20 06:35</time>
        </small></h1>
        <hr>
        <div class="e-content">
        <div><p></p><p>Here is an interesting thing that I found.  <code>x</code> is a SymPy Symbol:
<img src="2009/07/code-block-11.png" alt="Code block 1" title="Code block 1" width="174" height="86" class="alignnone size-full wp-image-207"></p>
<p>I would have expected to get <code>a = []</code>, but it only removes the first item.  And yes, <code>x + 1</code> passes the condition:</p>
<p><code></code></p>
<p>&gt;&gt;&gt; (x + 1).has(x)</p>
<p>True</p>
<p></p>
<p>Clearly, it is a bad idea to modify a list while I am looping through it. I should instead be doing something like this:</p>
<p><img src="2009/07/code-block-2.png" alt="Code block 2" title="Code block 2" width="203" height="111" class="alignnone size-full wp-image-204"></p>
<p>But I am intrigued as to why exactly this fails.  If any of the readers of the blog thinks that he know, please post in the comments.  Or, if I figure it out, I will post an update.  Also, here is a similar example, with a strange result:</p>
<p><img src="2009/07/code-block-3.png" alt="Code block 3" title="Code block 3" width="167" height="75" class="alignnone size-full wp-image-205"></p>
<p>(Sorry for the images by the way.  WordPress's so called "code" blocks are impervious to indentation.)</p>
<p>UPDATE (a few minutes later):</p>
<p>Well, I figured it would come to me as to why this was happening, and it didn't take long.  While I haven't read the actual <a href="http://docs.python.org/reference/index.html#reference-index">Python Language Reference</a>, this is what I am assuming is happening.  This is all just my guessing on how Python is implemented.  Please correct me if I am wrong.</p>
<p>So, obviously, a Python list is just a C array.  It is probably an array of pointers, which is the only way I can see that would let it be mutable with different objects (this is how compiled languages with dynamic typing like <a href="http://en.wikipedia.org/wiki/Objective_c">Objective-C</a> more or less pull it off).  Now C does not have the <code>for i in list</code> syntax that Python has (nor does any other language that I know of.  That is one of the reasons that Python is so awesome!), so if you want to recurse a list (C array), you have to do the usual <code>for (i=0; i&lt;=len(list); i++) {</code> from C (or it probably uses a while loop, which would allow for things like iterators, but a for loop in C is literally just a wrapper around a while loop anyway).  Then of course, inside of the loop, you just have <code>list[i]</code> blocks.  So when I was going through my list, for example, the list of numbers in the last example, it would hit item 0 (the first item), remove it, which would amount to rebuilding the list as <code>[2, 3, 4, 5]</code>, then it would hit item 1, which is now 3, remove it, rebuilding the list, and so on.  So the even numbered elements remain because it skips every element after one that it removes. CPython must have good error handling, because eventually this would cause the indices to go beyond the length of the list.  It seems to me that this behavior is not very well defined.  Personally, I think that whatever you are looping through in a for loop should become immutable within the loop block.  I checked Python 3.1, and the behavior is exactly the same.</p>
<p>Based on this, <code>.remove()</code> rebuilds the list each time.  I would have thought it would just set the value in the array to Null, but I guess that would make it more difficult to test equality with an equivalent list that doesn't have Null values.  It is good to know that <code>.remove()</code> does that, because it means that can be an expensive operation.  </p></div>
        </div>
            
        
    <p>
        <a href="posts/2009/07/20/modifying-a-list-while-looping-through-it-in-python.html#disqus_thread" data-disqus-identifier="cache/posts/2009/07/20/modifying-a-list-while-looping-through-it-in-python.html">Comments</a>


        </p></article>
        <article class="postbox h-entry post-text">
        <h1 class="p-name"><a href="posts/2009/07/16/constant-stuff.html" class="u-url">Constant stuff</a>
        <small>  
             Posted: <time class="published dt-published" datetime="2009-07-16T05:06:17+00:00">2009-07-16 05:06</time>
        </small></h1>
        <hr>
        <div class="e-content">
        <div><p></p><p>So I was able to get a working version of the Constant class, but because the code cluttered up the internal Add and Mul classes too much, Ondrej convinced me that to make a function that does the simplification instead, and I reluctantly agreed.  After begining work on it, I realized that it will be much easier to make it just an internal function that handles the special cases presented by <code>dsolve()</code>.  That means that it will only handle arbitrary constants that are independent of one variable, and it will only work with constants that are named as "C1", "C2", and so on.  </p>
<p>If we ever get the sympyx core that Ondrej and I worked on when I was in Los Alamos in, it will be easy for my to use a Constant class, because it will have handler logic that will allow for the Constant class to exist independent of Add and Mul. It already can exist independent of Pow with a minor code addition, but simplifying powers is easier than simplifying addition and multiplcation because exponentiation is neither commutative nor associative, meaning that you don't have to worry about absorbing stuff on the other side of something, like <code>2 + x + C</code>.  </p>
<p>See my <a href="http://github.com/asmeurer/sympy/tree/constant-Mul">constant-Mu</a>l branch for my working version of a Constant class the implements in Mul and Add.  See my <a href="http://github.com/asmeurer/sympy/tree/constant-function">constant-function</a> branch for my work on the internal function.</p>
<p>Because I have decided to make thing simple and make the function internal only, I should have things up and running soon.  Then, it will be simple to fix up my nth order homogeneous stuff that I already have so that it works, and then to implement variation of parameters!</p></div>
        </div>
            
        
    <p>
        <a href="posts/2009/07/16/constant-stuff.html#disqus_thread" data-disqus-identifier="cache/posts/2009/07/16/constant-stuff.html">Comments</a>


        </p></article>
        <article class="postbox h-entry post-text">
        <h1 class="p-name"><a href="posts/2009/07/13/meeting-ondrej-in-los-alamos.html" class="u-url">Meeting Ondrej in Los Alamos</a>
        <small>  
             Posted: <time class="published dt-published" datetime="2009-07-13T02:22:14+00:00">2009-07-13 02:22</time>
        </small></h1>
        <hr>
        <div class="e-content">
        <div><p></p><p>So Ondrej was kind enough to have me over to his house in Los Alamos for Friday and Saturday.  We spent a lot of time coding together.  While we worked on some other things too, we mainly worked on my constant class.  Ondrej and I came up with an idea for restructured Mul and Add classes that would allow different objects in them to handle the other objects in them.  The way it is now, if I want my Constant object to absorb other objects, like <code>2<em>a</em>C<em>x =&gt; C</em>x</code>, I have to hardcode it into Mul.  The same is true with Add.  This makes the Mul and Add classes muddy.  Right now, there is already special handling for other such dynamic objects such as Order classes (e.g., <code>O(x)</code>), and Infinity class.  See the <code>Add.flatten()</code> and <code>Mul.flatten()</code> methods in sympy/core/add.py and sympy.core/mul.py to see what I mean.  </p>
<p>We came up with a system where symbols and numbers are handled the same way, because we need them to be fast, but if an expression has an object that has a <code>handle_mul()</code> method, it will call that method with the other objects in the expression in the Mul/Add and the object will take care of the special handling.  Ondrej was able to get most of it working in his experimental core that doesn't use assumptions <a href="//github.com/certik/sympyx.git">here</a>.  We will hopefully end up using it, but we need to wait until we merge the new assumptions system. </p>
<p>So in the mean while, I have a working Constant class that modifies Mul and Add <a href="http://github.com/asmeurer/sympy/tree/constant-Mul">here</a>.  Since it will take a while until the new assumptions system is done (<a href="http://fseoane.net/blog/">Fabian Seoane</a> is doing it for his Google Summer of Code project), we may end up temporarily adding in my Constant branch.  Once I have a working Constant class, I can solve <a href="http://en.wikipedia.org/wiki/Linear_differential_equation#Homogeneous_linear_differential_equation_with_constant_coefficients">homogeneous differential equations</a> (not to be confused with <a href="http://asmeurersympy.wordpress.com/2009/05/31/first-order-differential-equations-with-homogeneous-coefficients/">first order differential equations with homogeneous coefficients</a>)  with one case (there are several cases depending on whether the roots of the so called characteristic equation are real, imaginary, or complex, but we can actually handle them in one case if we have constants that combine into each other.  More on this in a later post).  Once I have that (which I have everything already except for the arbitrary constants), I can then implement <a href="http://en.wikipedia.org/wiki/Variation_of_parameters">variation of parameters</a>, which, along with separable, will probably be the most used solver of the ones that I will implement this summer.  </p>
<p>Once I get those, I can clean up a lot of the 2nd order differential equation code in dsolve (currently it is just a hack with a bunch of special cases all covered by variation of parameters).  With that code cleaned up, I can refactor dsolve to use my proposed hints engine, which will allow the user to choose which methods they want to use to solve an equation (more on that in a later post too).  </p></div>
        </div>
            
        
    <p>
        <a href="posts/2009/07/13/meeting-ondrej-in-los-alamos.html#disqus_thread" data-disqus-identifier="cache/posts/2009/07/13/meeting-ondrej-in-los-alamos.html">Comments</a>


        </p></article>
        <article class="postbox h-entry post-text">
        <h1 class="p-name"><a href="posts/2009/07/06/update.html" class="u-url">Update</a>
        <small>  
             Posted: <time class="published dt-published" datetime="2009-07-06T18:12:26+00:00">2009-07-06 18:12</time>
        </small></h1>
        <hr>
        <div class="e-content">
        <div><p></p><p>It's been a while since I've posted here, so I figured an update was in order.  Here is a list of stuff that I have done since my last post.</p>
<ul>
<li>
<p>I recovered my data from my Terminal history.  This wasn't too difficult as I predicted.  I just had to do some minor formatting on the <code>git commit --interactive</code> data to make it a valid git patch file.  For whatever reason, a handful of the changes wouldn't apply because git couldn't find where changed lines were, even though they were identical to what was in the patch.  <code>git apply</code> doesn't seem to have a merge option, but eventually I found the <code>--reject</code> option, which puts failed patches in .rej files, instead of just failing the whole apply.</p>
</li>
<li>
<p>I got separable equations implemented in dsolve.  I actually did this on the road before I lost my data, but I failed to mention it before, so here it is.  The hardest part with that was creating a decent <code>separatevars()</code> function that could separate just about any funciton. As I mentioned in an <a href="http://asmeurersympy.wordpress.com/2009/06/21/refactoring-expand/">earlier post</a>, this involved changing the way that SymPy handles automatic combining of exponents in the core, as well as refactoring expand. I also had to make the function completely independent of <code>match</code>, because <code>match</code> is too buggy to work correctly for separable equations.  </p>
</li>
<li>
<p>Speaking of refactoring <code>expand</code> and combining exponents, that work made it in!  It is the first major thing that I have done that has actually made it into the main SymPy repo.  It got in just before the release of SymPy 0.6.5-beta2, so it should be in the final release of SymPy 0.6.5.  Most likely, none of my ODE stuff will make it in until 0.7.  </p>
</li>
<li>
<p>I started to work on <a href="http://en.wikipedia.org/wiki/Variation_of_parameters">Variation of Parameters</a>, but before I could actually get to the variation of parameters part, I needed to be able to solve a homogeneous equation $latex a_ny^{(n)}+a_{n-1}y^{(n-1)}+\dots+a_1y'+a_0y=0$ ($latex a_i$ constant for all $latex i$).  If you know how that works, it involves finding the roots of the polynomial given by $latex a_nr^n+a_{n-1}r^{n-1}+\dots+a_1r+a_0=0$.  Depending on whether these roots are real, imaginary, or complex, you have different solutions with exponentials or sin's and cos's.  I had no trouble getting the exponentials and the sin's and cos's to work correctly (SymPy already has a root finder that I put to work), but I did have a problem getting the arbitrary constants to work correcty.  It turns out that the code for that would be much simpler if I had an arbitrary constant type that automatically "absorbed" other constants.  Since I had planned on doing that anyway, I decided to put the rest of variation of parameters on hold and begin work on that.</p>
</li>
<li>
<p>We had a Documentation day on June 30, and I decided to write up a document that would help people new to SymPy and Python with some of the gotchas and pitfalls.  For example, unlike most other independent CAS's like Maple, you can't just type <code>1/2</code> in SymPy to get $latex \frac{1}{2}$.  That is because Python evaluates it numerically.  You have to do <code>S(1)/2</code> or <code>Rational(1,2)</code> to get the Rational class.  It's all things like that.  It's taken me a while to get it together, not because it took me long to write it, but because it has to be in the Sphinx documentation format, which I have had to learn.  I am just finishing it up now.</p>
</li>
<li>
<p>I met with Ondrej on Saturday.  He went down from Los Alamos to Carlsbad with a friend to see the caverns, and they stopped here in Albuquerque on the way back up.  He came just in time to see the fireworks, and after that got some dinner.  We weren't able to do any coding, but hopefully we will be able to meet up again later this summer to do some of that.</p>
</li>
</ul></div>
        </div>
            
        
    <p>
        <a href="posts/2009/07/06/update.html#disqus_thread" data-disqus-identifier="cache/posts/2009/07/06/update.html">Comments</a>


        </p></article>
        <article class="postbox h-entry post-text">
        <h1 class="p-name"><a href="posts/2009/06/22/how-to-permanently-lose-data-with-git-and-then-retrieve-it-again.html" class="u-url">How to permanently lose data with git (and then retrieve it again)</a>
        <small>  
             Posted: <time class="published dt-published" datetime="2009-06-22T05:16:23+00:00">2009-06-22 05:16</time>
        </small></h1>
        <hr>
        <div class="e-content">
        <div><p></p><p>So I pushed some changes to github so Ondrej could help me debug the nseries tests, when I noticed that the changes that I pushed had some bad comments.  So I decided to rebase.  But git rebase -i told me that there was already a rebase in progress.  I figured that I must have done it a long time ago and forgot to abort, so I ran git rebase --abort.  </p>
<p>DON'T DO THAT.</p>
<p>I noticed my editor was telling me that an open file had changed.  Then, I noticed that ALL of my uncommited changes were gone!  And, being uncommited changes, git did not have them saved anywhere!</p>
<p>So now I started to panic.  I had done a lot of work on dsolve that I hadn't commited yet. Normally, I have hourly backups run by <a href="http://www.apple.com/macosx/features/timemachine.html">Time Machine</a>, but I am on vacation and my backup drive is at home.  So I started to see if I could retrieve it somewhere.  grep quickly told me that it wasn't in the hidden git directory, but it was still in my .pyc files.  But a Google search told me that retrieving from that is not so easy, if not impossible with Python 2.6.  So then, I decided to see if there was any lingering stuff in my virtual memory from my editor.  So I ran grep on my harddrive and waited.  </p>
<p>While I was waiting, though, I noticed when I scrolled up in my command history that my lost changes were in my Terminal.  It turns out that I had just run git commit --interactive and had used * on my patches, so it gave me everything!  </p>
<p>So I copied my Terminal history and will work on putting everything back tomorrow.  It should be easy, assuming that git apply works for the format that git gives in commit --interactive.  </p>
<p>So the lessons are: Don't abort a rebase without commiting.  Don't start a rebase and then leave it there.  Look in your Terminal history if you loose stuff.  And it might be a good idea to make manual backups if you are away from your backup drive for a while.</p>
<p>This also highlights why it is important to try to recover data immediately after realizing that it is gone.  If I had closed my Terminal session or filled it past the maximum number of lines, my data would be gone.  Even if it were in my virtual memory, that wouldn't last forever either.  </p></div>
        </div>
            
        
    <p>
        <a href="posts/2009/06/22/how-to-permanently-lose-data-with-git-and-then-retrieve-it-again.html#disqus_thread" data-disqus-identifier="cache/posts/2009/06/22/how-to-permanently-lose-data-with-git-and-then-retrieve-it-again.html">Comments</a>


        </p></article>
        <article class="postbox h-entry post-text">
        <h1 class="p-name"><a href="posts/2009/06/21/refactoring-expand.html" class="u-url">Refactoring Expand</a>
        <small>  
             Posted: <time class="published dt-published" datetime="2009-06-21T04:48:54+00:00">2009-06-21 04:48</time>
        </small></h1>
        <hr>
        <div class="e-content">
        <div><p></p><p>So I have spent the past week refactoring expand so that you can have more control over what expansion methods you use.  With the present method, expand takes in hints which defaults to basic.  basic distributed multiplication over addition ($latex x(y+z) \rightarrow xy+xz$), expanded multinomial expressions ($latex (x+y)^2 \rightarrow x^2+2xy+y^2$), expanded logarithms ($latex \log{x^2} \rightarrow 2\log{x}$ and $latex \log{xy} \rightarrow \log{x}+\log{y}$), and expanded powers ($latex (xy)^n \rightarrow x^ny^n$ and $latex e^{x+y} \rightarrow e^{x}e^{y}$).  </p>
<p>If you wanted to do any of these things, you had to use expand_basic, which did all of them.  Also, you had no control on how deep the expansion went.  It went all they way down in recursion, so if you only wanted, for example, to distribute multiplication  on the top level, it was impossible.  </p>
<p>So I decided to start and fix <a href="http://code.google.com/p/sympy/issues/detail?id=1455">issue 1455</a>.  I now have a branch ready in my github account (see <a href="http://github.com/asmeurer/sympy/tree/expand">here</a>).  </p>
<p>With my patch, you can now choose to expand using each of the above individually with the log, mul, multinomial, power_exp, power_base.  In addition to this, you also now have complete control of how deep the expression recurses in the expand.  Previously, you couldn't, for example, expand $latex x(y+e^{x(y+z)})$ to $latex xy+xe^{x(y+z)}$. (It would also distribute the exponent, then expand to $latex e^{xy}e^{xz}$).  Now, you can choose to only distribute multiplication over addition, and to only do it on the top level.  </p>
<p><strong>Automatic expansion of exponents</strong></p>
<p>I mentioned above that expand would expand $latex e^{xy+xz}$ to $latex e^{xy}e^{xz}$. Actually, in the current version of SymPy, this would not happen because it automatically combines exponents like $latex e^{xy}e^{xz}$ to $latex e^{xy+xz}$.  </p>
<p>I have been working for the past few weeks changing this as per <a href="http://code.google.com/p/sympy/issues/detail?id=252&amp;q=asmeurer">issue 252</a>.   I have been mostly successful, except there are two nseries tests that I cannot figure out how to fix.  If you think you know why nseries would fail without automatic combining of exponents, please let me know.  The expand branch in my GitHub repo also has the exponent patches in it, if you want to see what I mean.  </p>
<p>Because some things, like the gruntz algorithm, rely on automatic combining of exponents, so I had to rework powsimp, which combined exponents but also combined bases ($latex x^ay^a$ to $latex (xy)^a$) so that it could only combine exponents.  That way, I could use it to get the old behavior where I needed it.  Use <code>powsimp(expr, deep=True, combine='exp')</code> in my branch to get the old automatic behavior.  </p>
<p><strong>So what does this have to do with ODEs?</strong></p>
<p>When I started working on separable equations, I wanted to be able to separate things like $latex e^{x+y}$ into $latex e^xe^y$, which is separable in $latex x$ and $latex y$.  So that is why I needed to refactor expand (I don't, for example, want to change $latex x(y+1)$ to $latex xy+x$ because the later is not easily recognizable as separate.  Doing this or course required that SymPy didn't automatically put back together $latex e^xe^y$ into $latex e^{x+y}$, so I had to fix that issue as well.  </p>
<p>I am almost finished implementing separable (there are some match issues that I will blog about later whenever I get them straightened out), and the only thing that is holding all of this back is those nseries tests.  If anyone is familiar with how those algorithms work and which parts require automatic combining of exponents, that would be great.  </p></div>
        </div>
            
        
    <p>
        <a href="posts/2009/06/21/refactoring-expand.html#disqus_thread" data-disqus-identifier="cache/posts/2009/06/21/refactoring-expand.html">Comments</a>


        </p></article>
        <article class="postbox h-entry post-text">
        <h1 class="p-name"><a href="posts/2009/06/13/vacation.html" class="u-url">Vacation</a>
        <small>  
             Posted: <time class="published dt-published" datetime="2009-06-13T00:45:44+00:00">2009-06-13 00:45</time>
        </small></h1>
        <hr>
        <div class="e-content">
        <div><p></p><p>I am on vacation now.  I am visiting the Grand Canyon, Hoover Dam, Yellowstone, and other places.  I will be able to do some coding on the road, but not as much as when I am home.  The vacation will last about a week.  Hopefully I will be able to get a blog post about what I have been doing in SymPy written up in the next few days. </p></div>
        </div>
            
        
    <p>
        <a href="posts/2009/06/13/vacation.html#disqus_thread" data-disqus-identifier="cache/posts/2009/06/13/vacation.html">Comments</a>


        </p></article>
    
        <div>
        <ul class="pager">
            <li class="previous">
                <a href="index-3.html" rel="prev">← Newer posts</a>
            </li>
            <li class="next">
                <a href="index-1.html" rel="next">Older posts →</a>
            </li>
        </ul>
        </div>

    
        
       <script>var disqus_shortname="asmeurer";(function(){var a=document.createElement("script");a.async=true;a.src="//"+disqus_shortname+".disqus.com/count.js";(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(a)}());</script>


	
        <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
          tex2jax: {inlineMath: [['$latex ','$'], ['\\(','\\)']]}
        });
        </script>
        <script src="assets/js/mathjax.js"></script>


        </div>
        <!--End of body content-->

        <footer>
            Contents © 2014         <a href="mailto:asmeurer@gmail.com">Aaron Meurer</a> - Powered by         <a href="http://getnikola.com" rel="nofollow">Nikola</a>         
        </footer>
    </div>
</div>


            <script src="assets/js/all-nocdn.js" type="text/javascript"></script>


    
<!-- Social buttons -->
<div id="addthisbox" class="addthis_toolbox addthis_peekaboo_style addthis_default_style addthis_label_style addthis_32x32_style">
<a class="addthis_button_more">Share</a>
<ul><li><a class="addthis_button_facebook"></a>
</li><li><a class="addthis_button_google_plusone_share"></a>
</li><li><a class="addthis_button_linkedin"></a>
</li><li><a class="addthis_button_twitter"></a>
</li></ul>
</div>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-4f7088a56bb93798"></script>
<!-- End of social buttons -->


    <script type="text/javascript">jQuery("a.image-reference").colorbox({rel:"gal",maxWidth:"100%",maxHeight:"100%",scalePhotos:true});</script>
    

</body>
</html>