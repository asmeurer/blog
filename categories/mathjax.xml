<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Aaron Meurer's Blog (Posts about mathjax)</title><link>https://asmeurer.github.io/blog/</link><description></description><atom:link href="https://asmeurer.github.io/blog/categories/mathjax.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><lastBuildDate>Fri, 27 Oct 2017 03:29:42 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>What happens when you mess with hashing in Python</title><link>https://asmeurer.github.io/blog/posts/what-happens-when-you-mess-with-hashing-in-python/</link><dc:creator>Aaron Meurer</dc:creator><description>&lt;div&gt;&lt;p&gt;&lt;em&gt;This post is based off a Jupyter notebook I made in 2013. You can download
the original &lt;a href="https://gist.github.com/asmeurer/6046766"&gt;here&lt;/a&gt;. That notebook
was based off a
&lt;a href="https://github.com/sympy/sympy/wiki/What-happens-when-you-mess-with-hashing"&gt;wiki page&lt;/a&gt;
on the SymPy wiki, which in turn was based on
&lt;a href="https://groups.google.com/forum/#%21msg/sympy/pJ2jg2csKgU/0nn21xqZEmwJ"&gt;a message&lt;/a&gt;
to the SymPy mailing list.&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;What is hashing?&lt;/h2&gt;
&lt;p&gt;Before we start, let's have a brief introduction to hashing. A
&lt;a href="https://en.wikipedia.org/wiki/Hash_function"&gt;&lt;em&gt;hash function&lt;/em&gt;&lt;/a&gt; is a function
that maps a set of objects to a set of integers. There are many kinds of hash
functions, which satisfy many different properties, but the most important
property that must be satisfied by any hash function is that it be a function
(in the mathematical sense), that is, if two objects are equal, then their
hash should also be equal.&lt;/p&gt;
&lt;p&gt;Usually, the set of integers that the hash function maps to is much smaller
than the set of objects, so that there will be multiple objects that hash to
the same value. However, generally for a hash function to be useful, the set
of integers should be large enough, and the hash function well distributed
enough that if two objects hash to the same value, then they are very likely
to be equal.&lt;/p&gt;
&lt;p&gt;To summarize, a hash function &lt;em&gt;must&lt;/em&gt; satisfy the property:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;If two objects are equal, then their hashes should be equal.&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Additionally, a &lt;em&gt;good&lt;/em&gt; hash function should satisfy the property:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;If two objects have the same hash, then they are likely to be the same
object.&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Since there are generally more possible objects than hash values, two objects
may hash to the same value. This is called a
&lt;a href="https://en.wikipedia.org/wiki/Hash_collision"&gt;hash collision&lt;/a&gt;, and anything
that deals with hashes should be able to deal with them.&lt;/p&gt;
&lt;p&gt;This won't be discussed here, but an additional property that a good hash
function should satisfy to be useful is this:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;The hash of an object should be cheap to compute.&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;What is it used for?&lt;/h2&gt;
&lt;p&gt;If we have a hash function that satisfies the above properties, then we can
use it to create from a collection of objects something called a &lt;em&gt;hash table&lt;/em&gt;.
Suppose we have a collection of objects, and given any object, we want to be
able to compute very quickly if that object belongs to our collection. We
could store these objects in an ordered array, but then to determine if it is
in the array, we would have to search potentially through every element of the
array (in other words, an \(O(n)\)) algorithm.&lt;/p&gt;
&lt;p&gt;With hashing, we can do better. We create what is known as a
&lt;a href="https://en.wikipedia.org/wiki/Hash_table"&gt;&lt;em&gt;hash table&lt;/em&gt;&lt;/a&gt;. Instead of storing
the objects in an ordered array, we create an array of buckets, each
corresponding to some hash values. We then hash each object, and store it into
the array corresponding to its hash value (if there are more hash values than
buckets, we distribute them using a second hash function, which can be as
simple as taking the modulus with respect to the number of buckets, &lt;code&gt;% n&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;This image from
&lt;a href="https://en.wikipedia.org/wiki/File:Hash_table_3_1_1_0_1_0_0_SP.svg"&gt;Wikipedia&lt;/a&gt;
shows an example.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://upload.wikimedia.org/wikipedia/commons/7/7d/Hash_table_3_1_1_0_1_0_0_SP.svg" alt="img"&gt;&lt;/p&gt;
&lt;p&gt;To determine if an object is in a hash table, we only have to hash the object,
and look in the bucket corresponding to that hash. This is an \(O(1)\)
algorithm, assuming we have a good hash function, because each bucket will
generally hold very few objects, possibly even none.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Note: there are some additional things that need to be done to handle hash
collisions, but the basic idea is the same, and as long as there aren't too
many hash collisions, which should happen if hash values are evenly
distributed and the size of the hash table is large compared to the number of
objects stored in it, the average time to determine if an object is in the
hash table is still \(O(1)\).&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;Hashing in Python&lt;/h2&gt;
&lt;p&gt;Python has a built in function that performs a hash called &lt;code&gt;hash()&lt;/code&gt;.  For many
objects, the hash is not very surprising.  Note, the hashes you see below may
not be the same ones you see if you run the examples, because Python hashing
depends on the architecture of the machine you are running on, and, in newer
versions of Python, hashes are randomized for security purposes.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; hash(10)
10
&amp;gt;&amp;gt;&amp;gt; hash(()) # An empty tuple
3527539
&amp;gt;&amp;gt;&amp;gt; hash('a')
12416037344
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In Python, not all objects are hashable. For example&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; hash([]) # An empty list
Traceback (most recent call last):
  File "&amp;lt;stdin&amp;gt;", line 1, in &amp;lt;module&amp;gt;
TypeError: unhashable type: 'list'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is because Python has an additional restriction on hashing:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;In order for an object to be hashable, it must be immutable.&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This is important basically because we want the hash of an object to remain
the same across the object's lifetime. But if we have a mutable object, then
that object itself can change over its lifetime. But then according to our
first bullet point above, that object's hash has to change too.&lt;/p&gt;
&lt;p&gt;This restriction simplifies hash tables. If we allowed an object's hash to
change while it is in a hash table, we would have to move it to a different
bucket. Not only is this costly, but the hash table would have to &lt;em&gt;notice&lt;/em&gt;
that this happened; the object itself doesn't know that it is sitting in a
hash table, at least not in the Python implementation.&lt;/p&gt;
&lt;p&gt;In Python, there are two objects that correspond to hash tables, &lt;code&gt;dict&lt;/code&gt; and
&lt;code&gt;set&lt;/code&gt;. A &lt;code&gt;dict&lt;/code&gt; is a special kind of hash table called an
&lt;a href="https://en.wikipedia.org/wiki/Associative_array"&gt;&lt;em&gt;associative array&lt;/em&gt;&lt;/a&gt;. An
associative array is a hash table where each element of the hash table points
to another object. The other object itself is not hashed.&lt;/p&gt;
&lt;p&gt;Think of an associative array as a generalization of a regular array (like a
&lt;code&gt;list&lt;/code&gt;). In a &lt;code&gt;list&lt;/code&gt;, objects are associated to nonnegative integer indices,
like&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; l = ['a', 'b', 7]
&amp;gt;&amp;gt;&amp;gt; l[0]
'a'
&amp;gt;&amp;gt;&amp;gt; l[2]
7
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In an associative array (i.e., a &lt;code&gt;dict&lt;/code&gt;) we can index objects by anything, so
long as the key is hashable.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; d = {0: 'a', 'hello': ['world']}
&amp;gt;&amp;gt;&amp;gt; d[0]
'a'
&amp;gt;&amp;gt;&amp;gt; d['hello']
['world']
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that only the keys need to be hashable. The values can be anything, even
unhashable objects like lists.&lt;/p&gt;
&lt;p&gt;The uses for associative arrays are boundless. &lt;code&gt;dict&lt;/code&gt; is one of the most
useful data types in the Python language. Some example uses are&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Extension of &lt;code&gt;list&lt;/code&gt; with "missing values". For example, &lt;code&gt;{0: 'a', 2: 7}&lt;/code&gt;
would correspond to the above list &lt;code&gt;l&lt;/code&gt; with the value &lt;code&gt;'b'&lt;/code&gt; corresponding to
the key &lt;code&gt;1&lt;/code&gt; removed.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Representation of a mathematical function with a finite domain.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A poor-man's database (the Wikipedia image above is an associative array
mapping names to telephone numbers).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Implementing a &lt;a href="https://stackoverflow.com/q/60208/161801"&gt;Pythonic version&lt;/a&gt;
of the switch-case statement.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The other type of hash table, &lt;code&gt;set&lt;/code&gt;, more closely matches the definition I
gave above for a hash table. A &lt;code&gt;set&lt;/code&gt; is just a container of hashable
objects. &lt;code&gt;set&lt;/code&gt;s are unordered, and can only contain one of each object (this
is why they are called "sets," because this matches the mathematical
definition of a &lt;a href="https://en.wikipedia.org/wiki/Set_(mathematics)"&gt;set&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;In Python 2.7 or later, you can create a set with &lt;code&gt;{&lt;/code&gt; and &lt;code&gt;}&lt;/code&gt;, like &lt;code&gt;{a, b, c}&lt;/code&gt;. Otherwise, use &lt;code&gt;set([a, b, c])&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; s = {0, (), '2'}
&amp;gt;&amp;gt;&amp;gt; s
{0, '2', ()}
&amp;gt;&amp;gt;&amp;gt; s.add(1)
&amp;gt;&amp;gt;&amp;gt; s
{0, 1, '2', ()}
&amp;gt;&amp;gt;&amp;gt; s.add(0)
&amp;gt;&amp;gt;&amp;gt; s
{0, 1, '2', ()}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A final note: &lt;code&gt;set&lt;/code&gt; and &lt;code&gt;dict&lt;/code&gt; are themselves mutable, and hence not hashable!
There is an immutable version of &lt;code&gt;set&lt;/code&gt; called &lt;code&gt;frozenset&lt;/code&gt;. There are no
immutable dictionaries.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; f = frozenset([0, (), '2'])
&amp;gt;&amp;gt;&amp;gt; f
frozenset({0, '2', ()})
&amp;gt;&amp;gt;&amp;gt; hash(f)
-7776452922777075760
&amp;gt;&amp;gt;&amp;gt; # A frozenset, unlike a set, can be used as a dictionary key
&amp;gt;&amp;gt;&amp;gt; d[f] = 'a set'
&amp;gt;&amp;gt;&amp;gt; d
{0: 'a', frozenset({0, '2', ()}): 'a set', 'hello': ['world']}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Creating your own hashable objects&lt;/h2&gt;
&lt;p&gt;Before we move on, there is one final thing we need to know about hashing in
Python, which is how to create hashes for custom objects. By default, if we
create an object, it will be hashable.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; class Nothing(object):
...     pass
...
&amp;gt;&amp;gt;&amp;gt; N = Nothing()
&amp;gt;&amp;gt;&amp;gt; hash(N)
270498113
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Implementation-wise, the hash is just the object's &lt;code&gt;id&lt;/code&gt;, which corresponds to
its position in memory. This satisfies the above conditions: it is (extremely)
cheap to compute, and since by default objects in Python compare unequal to
one another, objects with different hashes will be unequal.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; M = Nothing()
&amp;gt;&amp;gt;&amp;gt; M == N
False
&amp;gt;&amp;gt;&amp;gt; hash(M)
270498117
&amp;gt;&amp;gt;&amp;gt; hash(M) == hash(N)
False
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To define a hash function for an object, define the &lt;code&gt;__hash__&lt;/code&gt; method.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; class HashToOne(object):
...     def __hash__(self):
...         return 1
...
&amp;gt;&amp;gt;&amp;gt; HTO = HashToOne()
&amp;gt;&amp;gt;&amp;gt; hash(HTO)
1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To set an object as not hashable, set &lt;code&gt;__hash__&lt;/code&gt; to &lt;code&gt;None&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; class NotHashable(object):
...     __hash__ = None
...
&amp;gt;&amp;gt;&amp;gt; NH = NotHashable()
&amp;gt;&amp;gt;&amp;gt; hash(NH)
Traceback (most recent call last):
  File "&amp;lt;stdin&amp;gt;", line 1, in &amp;lt;module&amp;gt;
TypeError: unhashable type: 'NotHashable'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Finally, to override the equality operator &lt;code&gt;==&lt;/code&gt;, define &lt;code&gt;__eq__&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; class AlwaysEqual(object):
...     def __eq__(self, other):
...         if isinstance(other, AlwaysEqual):
...             return True
...         return False
...
&amp;gt;&amp;gt;&amp;gt; AE1 = AlwaysEqual()
&amp;gt;&amp;gt;&amp;gt; AE2 = AlwaysEqual()
&amp;gt;&amp;gt;&amp;gt; AE1 == AE2
True
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;One of the key points that I hope you will take away from this post is that if
you override &lt;code&gt;__eq__&lt;/code&gt; and you want a hashable object, you &lt;strong&gt;must&lt;/strong&gt; also
override &lt;code&gt;__hash__&lt;/code&gt; to agree. Note that Python 3 will actually require this:
in Python 3, if you override &lt;code&gt;__eq__&lt;/code&gt;, it automatically sets &lt;code&gt;__hash__&lt;/code&gt; to
&lt;code&gt;None&lt;/code&gt;, making the object unhashable. You need to manually override &lt;code&gt;__hash__&lt;/code&gt;
to make it hashable again. But that's as far as Python goes in enforcing these
rules, as we will see below. In particular, Python will never actually check
that your &lt;code&gt;__hash__&lt;/code&gt; actually agrees with your &lt;code&gt;__eq__&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;Messing with hashing&lt;/h2&gt;
&lt;p&gt;Now to the fun stuff. What happens if we break some of the invariants that
Python expects of hashing. Python expects two key invariants to hold&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;The hash of an object does not change across the object's lifetime (in
other words, a hashable object should be immutable).&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;a == b&lt;/code&gt; implies &lt;code&gt;hash(a) == hash(b)&lt;/code&gt; (note that the reverse might not
hold in the case of a hash collision).&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;As we shall see, Python expects, but does not enforce either of these.&lt;/p&gt;
&lt;h3&gt;Example 1: Mutating a hash&lt;/h3&gt;
&lt;p&gt;Let's break rule 1 first. Let's create an object with a hash, and then change
that object's hash over its lifetime, and see what sorts of things can happen.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; class Bad(object):
...     def __init__(self, hash): # The object's hash will be hash
...         self.hash = hash
...     def __hash__(self):
...         return self.hash
...
&amp;gt;&amp;gt;&amp;gt; b = Bad(1)
&amp;gt;&amp;gt;&amp;gt; hash(b)
1
&amp;gt;&amp;gt;&amp;gt; d = {b:42}
&amp;gt;&amp;gt;&amp;gt; d[b]
42
&amp;gt;&amp;gt;&amp;gt; b.hash = 2
&amp;gt;&amp;gt;&amp;gt; hash(b)
2
&amp;gt;&amp;gt;&amp;gt; d[b]
Traceback (most recent call last):
  File "&amp;lt;stdin&amp;gt;", line 1, in &amp;lt;module&amp;gt;
KeyError: &amp;lt;__main__.Bad object at 0x1047e7438&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here, we implicitly changed the hash of &lt;code&gt;b&lt;/code&gt; by mutating the attribute of &lt;code&gt;b&lt;/code&gt;
that is used to compute the hash. As a result, the object is no longer found
in a dictionary, which uses the hash to find the object.&lt;/p&gt;
&lt;p&gt;The object is still there, we just can't access it any more.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; d
{&amp;lt;__main__.Bad object at 0x1047e7438&amp;gt;: 42}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that Python doesn't prevent me from doing this. We could make it if we
want (e.g., by making &lt;code&gt;__setattr__&lt;/code&gt; raise &lt;code&gt;AttributeError&lt;/code&gt;), but even then we
could forcibly change it by modifying the object's &lt;code&gt;__dict__&lt;/code&gt;. We could try
some more fancy things using descriptors, metaclasses, and/or
&lt;code&gt;__getattribute__&lt;/code&gt;, but even then, if we knew what was happening, we could
probably find a way to change it.&lt;/p&gt;
&lt;p&gt;This is what is meant when people say that Python is a "consenting adults"
language. You are expected to not try to break things, but generally aren't
prevented from doing so if you try.&lt;/p&gt;
&lt;h3&gt;Example 2: More mutation&lt;/h3&gt;
&lt;p&gt;Let's try something even more crazy. Let's make an object that hashes to a
different value each time we look at the hash.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; class DifferentHash(object):
...     def __init__(self):
...         self.hashcounter = 0
...     def __hash__(self):
...         self.hashcounter += 1
...         return self.hashcounter
...
&amp;gt;&amp;gt;&amp;gt; DH = DifferentHash()
&amp;gt;&amp;gt;&amp;gt; hash(DH)
1
&amp;gt;&amp;gt;&amp;gt; hash(DH)
2
&amp;gt;&amp;gt;&amp;gt; hash(DH)
3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Obviously, if we use &lt;code&gt;DH&lt;/code&gt; as a key to a dictionary, then it will not work,
because we will run into the same issue we had with &lt;code&gt;Bad&lt;/code&gt;. But what about
putting &lt;code&gt;DH&lt;/code&gt; in a &lt;code&gt;set&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; DHset = {DH, DH, DH}
&amp;gt;&amp;gt;&amp;gt; DHset
{&amp;lt;__main__.DifferentHash at 0x101f79f50&amp;gt;,
 &amp;lt;__main__.DifferentHash at 0x101f79f50&amp;gt;,
 &amp;lt;__main__.DifferentHash at 0x101f79f50&amp;gt;}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Woah! We put the exact same object in a &lt;code&gt;set&lt;/code&gt; three times, and it appeared all
three times. This is not what is supposed to happen with a set.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; {1, 1, 1}
{1}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;What happens when we do stuff with &lt;code&gt;DHset&lt;/code&gt;?&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; DHset.remove(DH)
Traceback (most recent call last):
  File "&amp;lt;stdin&amp;gt;", line 1, in &amp;lt;module&amp;gt;
KeyError: &amp;lt;__main__.DifferentHash object at 0x1047e75f8&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That didn't work, because &lt;code&gt;set.remove&lt;/code&gt; searches for an object by its hash,
which is different by this point.&lt;/p&gt;
&lt;p&gt;Now let's make a copy of &lt;code&gt;DHset&lt;/code&gt;. The &lt;code&gt;set.copy&lt;/code&gt; method will create a shallow
copy (meaning that the set container itself will be different, according to
&lt;code&gt;is&lt;/code&gt; comparison, but the objects themselves will the same, according to &lt;code&gt;is&lt;/code&gt;
comparison).&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; DHset2 = DHset.copy()
&amp;gt;&amp;gt;&amp;gt; DHset2 == DHset
True
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Everything is fine so far. This object is only going to cause trouble if
something recomputes its hash. But remember that the whole reason that we had
trouble with something like &lt;code&gt;Bad&lt;/code&gt; above is that Python &lt;em&gt;doesn't&lt;/em&gt; recompute
that hash of an object, unless it has to. So let's do something that will
force it to do so: let's pop an object from one of the sets and add it back
in.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; D = DHset.pop()
&amp;gt;&amp;gt;&amp;gt; DHset.add(D)
&amp;gt;&amp;gt;&amp;gt; DHset
{&amp;lt;__main__.DifferentHash at 0x101f79f50&amp;gt;,
 &amp;lt;__main__.DifferentHash at 0x101f79f50&amp;gt;,
 &amp;lt;__main__.DifferentHash at 0x101f79f50&amp;gt;}
&amp;gt;&amp;gt;&amp;gt; DHset2
{&amp;lt;__main__.DifferentHash at 0x101f79f50&amp;gt;,
 &amp;lt;__main__.DifferentHash at 0x101f79f50&amp;gt;,
 &amp;lt;__main__.DifferentHash at 0x101f79f50&amp;gt;}
&amp;gt;&amp;gt;&amp;gt; DHset == DHset2
False
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There we go. By removing it from the set, we made the set forget about its
hash, so it had to be recomputed when we added it again. This version of
&lt;code&gt;DHset&lt;/code&gt; now has a &lt;code&gt;DH&lt;/code&gt; with a different hash than it had before. Thinking back
to &lt;code&gt;set&lt;/code&gt; being a hash table, in this &lt;code&gt;DHset&lt;/code&gt;, the three &lt;code&gt;DH&lt;/code&gt; objects are in
different "buckets" than they were in before. &lt;code&gt;DHset.__eq__(DHset2)&lt;/code&gt; notices
that the bucket structure is different right away and returns &lt;code&gt;False&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;By the way, what hash value are we up to these days?&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; hash(DH)
9
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Example 3: When &lt;code&gt;a == b&lt;/code&gt; does not imply &lt;code&gt;hash(a) == hash(b)&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;Now let's look at point 2. What happens if we create an object with &lt;code&gt;__eq__&lt;/code&gt;
that disagrees with &lt;code&gt;__hash__&lt;/code&gt;. For Python 2, we already have made a class like
this, the &lt;code&gt;AlwaysEqual&lt;/code&gt; object above. Instances of &lt;code&gt;AlwaysEqual&lt;/code&gt; will always
compare equal to one another, but they will not have the same hash, because
they will use &lt;code&gt;object&lt;/code&gt;'s default &lt;code&gt;__hash__&lt;/code&gt; of &lt;code&gt;id&lt;/code&gt;. For Python 3, however,
&lt;code&gt;AlwaysEqual&lt;/code&gt; is automatically set as unhashable because we overrode &lt;code&gt;__eq__&lt;/code&gt;
without also overriding &lt;code&gt;__hash__&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This blog post originally used the &lt;code&gt;AE1&lt;/code&gt; and &lt;code&gt;AE2&lt;/code&gt; objects we created above
for the next example, but to make it work in both Python 2 and 3, let's create
a custom &lt;code&gt;AlwaysEqual&lt;/code&gt; subclass that is hashable.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;&amp;gt;&amp;gt;&amp;gt; class AlwaysEqualHashable(AlwaysEqual):
...     def __hash__(self):
...         return id(self)
...
&amp;gt;&amp;gt;&amp;gt; AE1 = AlwaysEqualHashable()
&amp;gt;&amp;gt;&amp;gt; AE2 = AlwaysEqualHashable()
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; hash(AE1)
270498221
&amp;gt;&amp;gt;&amp;gt; hash(AE2)
270498197
&amp;gt;&amp;gt;&amp;gt; hash(AE1) == hash(AE2)
False
&amp;gt;&amp;gt;&amp;gt; AE1 == AE2
True
&amp;gt;&amp;gt;&amp;gt; {AE1, AE2}
{&amp;lt;__main__.AlwaysEqualHashable at 0x101f79950&amp;gt;,
 &amp;lt;__main__.AlwaysEqualHashable at 0x101f79ad0&amp;gt;}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can already see that we have broken one of the key properties of a &lt;code&gt;set&lt;/code&gt;,
which is that it does not contain the same object twice (remember that &lt;code&gt;AE1&lt;/code&gt;
and &lt;code&gt;AE2&lt;/code&gt; should be considered the "same object" because &lt;code&gt;AE1 == AE2&lt;/code&gt; is
&lt;code&gt;True&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;This can lead to subtle issues. For example, suppose we had a list and we
wanted to remove all the duplicate items from it. An easy way to do this is to
convert the list to a set and then convert it back to a list.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; l = ['a', 'a', 'c', 'a', 'c', 'b']
&amp;gt;&amp;gt;&amp;gt; list(set(l))
['a', 'b', 'c']
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, this method is obviously not going to work for a list of &lt;code&gt;AlwaysEqualHashable&lt;/code&gt; objects.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; AE3 = AlwaysEqualHashable()
&amp;gt;&amp;gt;&amp;gt; l = [AE1, AE1, AE3, AE2, AE3]
&amp;gt;&amp;gt;&amp;gt; list(set(l))
[&amp;lt;__main__.AlwaysEqualHashable at 0x102c1d590&amp;gt;,
 &amp;lt;__main__.AlwaysEqualHashable at 0x101f79ad0&amp;gt;,
 &amp;lt;__main__.AlwaysEqualHashable at 0x101f79950&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Actually, what happened here is that the equality that we defined on
&lt;code&gt;AlwaysEqual&lt;/code&gt; was essentially ignored. We got a list of unique items by &lt;code&gt;id&lt;/code&gt;,
instead of by &lt;code&gt;__eq__&lt;/code&gt;. You can imagine that if &lt;code&gt;__eq__&lt;/code&gt; were something a
little less trivial, where some, but not all, objects are considered equal,
that this could lead to very subtle issues.&lt;/p&gt;
&lt;p&gt;But there is an issue with the above algorithm. It isn't stable, that is, it
removes the ordering that we had on the list. We could do this better by
making a new list, and looping through the old one, adding elements to the new
list if they aren't already there.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; def uniq(l):
...     newl = []
...     for i in l:
...         if i not in newl:
...             newl.append(i)
...     return newl
...
&amp;gt;&amp;gt;&amp;gt; uniq(['a', 'a', 'c', 'a', 'c', 'b'])
['a', 'c', 'b']
&amp;gt;&amp;gt;&amp;gt; uniq([AE1, AE1, AE3, AE2, AE3])
[&amp;lt;__main__.AlwaysEqualHashable at 0x101f79ad0&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This time, we used &lt;code&gt;in&lt;/code&gt;, which uses &lt;code&gt;==&lt;/code&gt;, so we got only one unique element of
the list of &lt;code&gt;AlwaysEqual&lt;/code&gt; objects.&lt;/p&gt;
&lt;p&gt;But there is an issue with this algorithm as well. Checking if something is in
a list is \(O(n)\), but we have an object that allows checking in \(O(1)\)
time, namely, a &lt;code&gt;set&lt;/code&gt;. So a more efficient version might be to create a set
alongside the new list for containment checking purposes.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; def uniq2(l):
...     newl = []
...     newlset = set()
...     for i in l:
...         if i not in newlset:
...             newl.append(i)
...             newlset.add(i)
...     return newl
...
&amp;gt;&amp;gt;&amp;gt; uniq2(['a', 'a', 'c', 'a', 'c', 'b'])
['a', 'c', 'b']
&amp;gt;&amp;gt;&amp;gt; uniq2([AE1, AE1, AE3, AE2, AE3])
[&amp;lt;__main__.AlwaysEqualHashable at 0x101f79ad0&amp;gt;,
 &amp;lt;__main__.AlwaysEqualHashable at 0x102c1d590&amp;gt;,
 &amp;lt;__main__.AlwaysEqualHashable at 0x101f79950&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Bah! Since we used a set, we compared by hashing, not equality, so we are left
with three objects again. Notice the extremely subtle difference
here. Basically, it is this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; AE1 in {AE2}
False
&amp;gt;&amp;gt;&amp;gt; AE1 in [AE2]
True
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Set containment uses hashing; list containment uses equality. If the two don't
agree, then the result of your algorithm will depend on which one you use!&lt;/p&gt;
&lt;p&gt;By the way, as you might expect, dictionary containment also uses hashing, and
tuple containment uses equality:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; AE1 in {AE2: 42}
False
&amp;gt;&amp;gt;&amp;gt; AE1 in (AE2,)
True
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Example 4: Caching hashing&lt;/h3&gt;
&lt;p&gt;If you ever want to add subtle bizarreness to a system, add some sort of
caching, and then do it wrong.&lt;/p&gt;
&lt;p&gt;As we noted in the beginning, one important property of a hash function is
that it is quick to compute. A nice way to achieve this for heavily cached
objects is to cache the value of the cache on the object, so that it only
needs to be computed once. The pattern (which is modeled after SymPy's
&lt;code&gt;Basic&lt;/code&gt;) is something like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; class HashCache(object):
...     def __init__(self, arg):
...         self.arg = arg
...         self.hash_cache = None
...     def __hash__(self):
...         if self.hash_cache is None:
...             self.hash_cache = hash(self.arg)
...         return self.hash_cache
...     def __eq__(self, other):
...         if not isinstance(other, HashCache):
...             return False
...         return self.arg == other.arg
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;HashCache&lt;/code&gt; is nothing more than a small wrapper around a hashable argument,
which caches its hash.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; hash('a')
12416037344
&amp;gt;&amp;gt;&amp;gt; a = HashCache('a')
&amp;gt;&amp;gt;&amp;gt; hash(a)
12416037344
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For ordinary Python builtins, simply recomputing the hash will be faster than
the attribute lookup used by &lt;code&gt;HashCache&lt;/code&gt;. &lt;em&gt;Note: This uses the &lt;code&gt;%timeit&lt;/code&gt; magic
from IPython. &lt;code&gt;%timeit&lt;/code&gt; only works when run in IPython or Jupyter.&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; %timeit hash('a')
10000000 loops, best of 3: 69.9 ns per loop
&amp;gt;&amp;gt;&amp;gt; %timeit hash(a)
1000000 loops, best of 3: 328 ns per loop
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But for a custom object, computing the hash may be more computationally
expensive. As hashing is supposed to agree with equality (as I hope you've
realized by now!), if computing equality is expensive, computing a hash
function that agrees with it might be expensive as well.&lt;/p&gt;
&lt;p&gt;As a simple example of where this might be useful, consider a highly nested
tuple, an object whose hash that is relatively expensive to compute.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; a = ()
&amp;gt;&amp;gt;&amp;gt; for i in range(1000):
...     a = (a,)
...
&amp;gt;&amp;gt;&amp;gt; A = HashCache(a)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; %timeit hash(a)
100000 loops, best of 3: 9.61 Âµs per loop
&amp;gt;&amp;gt;&amp;gt; %timeit hash(A)
1000000 loops, best of 3: 325 ns per loop
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So far, we haven't done anything wrong. &lt;code&gt;HashCache&lt;/code&gt;, as you may have noticed,
has &lt;code&gt;__eq__&lt;/code&gt; defined correctly:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; HashCache(1) == HashCache(2)
False
&amp;gt;&amp;gt;&amp;gt; HashCache(1) == HashCache(1)
True
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But what happens if we mutate a &lt;code&gt;HashCache&lt;/code&gt;. This is different from examples 1
and 2 above, because we will be mutating what happens with equality testing,
but not the hash (because of the cache).&lt;/p&gt;
&lt;p&gt;&lt;em&gt;In the below example, recall that small integers hash to themselves, so
&lt;code&gt;hash(1) == 1&lt;/code&gt; and &lt;code&gt;hash(2) == 2&lt;/code&gt;.&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; a = HashCache(1)
&amp;gt;&amp;gt;&amp;gt; d = {a: 42}
&amp;gt;&amp;gt;&amp;gt; a.arg = 2
&amp;gt;&amp;gt;&amp;gt; hash(a)
1
&amp;gt;&amp;gt;&amp;gt; d[a]
42
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Because we cached the hash of &lt;code&gt;a&lt;/code&gt;, which was computed as soon as we created
the dictionary &lt;code&gt;d&lt;/code&gt;, it remained unchanged when modified the arg to be
&lt;code&gt;2&lt;/code&gt;. Thus, we can still find the key of the dictionary. But since we have
mutated &lt;code&gt;a&lt;/code&gt;, the equality testing on it has changed. This means that, as with
the previous example, we are going to have issues with dicts and sets keeping
unique keys and entries (respectively).&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; a = HashCache(1)
&amp;gt;&amp;gt;&amp;gt; b = HashCache(2)
&amp;gt;&amp;gt;&amp;gt; hash(a)
1
&amp;gt;&amp;gt;&amp;gt; hash(b)
2
&amp;gt;&amp;gt;&amp;gt; b.arg = 1
&amp;gt;&amp;gt;&amp;gt; a == b
True
&amp;gt;&amp;gt;&amp;gt; hash(a) == hash(b)
False
&amp;gt;&amp;gt;&amp;gt; {a, b}
{&amp;lt;__main__.HashCache at 0x102c32050&amp;gt;, &amp;lt;__main__.HashCache at 0x102c32450&amp;gt;}
&amp;gt;&amp;gt;&amp;gt; uniq([a, b])
[&amp;lt;__main__.HashCache at 0x102c32050&amp;gt;]
&amp;gt;&amp;gt;&amp;gt; uniq2([a, b])
[&amp;lt;__main__.HashCache at 0x102c32050&amp;gt;, &amp;lt;__main__.HashCache at 0x102c32450&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Once we mutate &lt;code&gt;b&lt;/code&gt; so that it compares equal to &lt;code&gt;a&lt;/code&gt;, we start to have the same sort of issues that we had in example 3 with &lt;code&gt;AlwaysEqualHashable&lt;/code&gt;. Let's look at an instant replay.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; a = HashCache(1)
&amp;gt;&amp;gt;&amp;gt; b = HashCache(2)
&amp;gt;&amp;gt;&amp;gt; b.arg = 1
&amp;gt;&amp;gt;&amp;gt; print(a == b)
True
&amp;gt;&amp;gt;&amp;gt; print(hash(a) == hash(b))
True
&amp;gt;&amp;gt;&amp;gt; print({a, b})
{&amp;lt;__main__.HashCache object at 0x102c32a10&amp;gt;}
&amp;gt;&amp;gt;&amp;gt; print(uniq([a, b]))
[&amp;lt;__main__.HashCache object at 0x102c32a50&amp;gt;]
&amp;gt;&amp;gt;&amp;gt; print(uniq2([a, b]))
[&amp;lt;__main__.HashCache object at 0x102c32a50&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Wait a minute, this time it's different! Comparing it to above, it's pretty
easy to see what was different this time. We left out the part where we showed
the hash of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;. When we did that the first time, it cached the hash
of &lt;code&gt;b&lt;/code&gt;, making it forever be &lt;code&gt;2&lt;/code&gt;, but when we didn't do it the second time,
the hash had not been cached yet, so the first time it is computed (in the
&lt;code&gt;print(hash(a) == hash(b))&lt;/code&gt; line), &lt;code&gt;b.arg&lt;/code&gt; has already been changed to &lt;code&gt;1&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;And herein lies the extreme subtlety: if you mutate an object with that hashes
its cache like this, you will run into issues &lt;strong&gt;only if&lt;/strong&gt; you had already
called some function that hashed the object somewhere. Now just about anything
might compute the hash of an object. Or it might not. For example, our &lt;code&gt;uniq2&lt;/code&gt;
function computes the hash of the objects in its input list, because it stores
them in a set, but &lt;code&gt;uniq&lt;/code&gt; does not:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; a = HashCache(1)
&amp;gt;&amp;gt;&amp;gt; b = HashCache(2)
&amp;gt;&amp;gt;&amp;gt; uniq2([a, b])
&amp;gt;&amp;gt;&amp;gt; b.arg = 1
&amp;gt;&amp;gt;&amp;gt; print(a == b)
True
&amp;gt;&amp;gt;&amp;gt; print(hash(a) == hash(b))
False
&amp;gt;&amp;gt;&amp;gt; print({a, b})
{&amp;lt;__main__.HashCache object at 0x102c32c50&amp;gt;, &amp;lt;__main__.HashCache object at 0x102c32c10&amp;gt;}
&amp;gt;&amp;gt;&amp;gt; print(uniq([a, b]))
[&amp;lt;__main__.HashCache object at 0x102c32c50&amp;gt;]
&amp;gt;&amp;gt;&amp;gt; print(uniq2([a, b]))
[&amp;lt;__main__.HashCache object at 0x102c32c50&amp;gt;, &amp;lt;__main__.HashCache object at 0x102c32c10&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; a = HashCache(1)
&amp;gt;&amp;gt;&amp;gt; b = HashCache(2)
&amp;gt;&amp;gt;&amp;gt; uniq([a, b])
&amp;gt;&amp;gt;&amp;gt; b.arg = 1
&amp;gt;&amp;gt;&amp;gt; print(a == b)
True
&amp;gt;&amp;gt;&amp;gt; print(hash(a) == hash(b))
True
&amp;gt;&amp;gt;&amp;gt; print({a, b})
{&amp;lt;__main__.HashCache object at 0x102c32c90&amp;gt;}
&amp;gt;&amp;gt;&amp;gt; print(uniq([a, b]))
[&amp;lt;__main__.HashCache object at 0x102c32bd0&amp;gt;]
&amp;gt;&amp;gt;&amp;gt; print(uniq2([a, b]))
[&amp;lt;__main__.HashCache object at 0x102c32bd0&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The moral of this final example is that if you are going to cache something,
that something had better be immutable.&lt;/p&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;The conclusion is this: don't mess with hashing. The two invariants above are
important. Let's restate them here,&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;The hash of an object must not change across the object's lifetime (in
other words, a hashable object should be immutable).&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;a == b&lt;/code&gt; implies &lt;code&gt;hash(a) == hash(b)&lt;/code&gt; (note that the reverse might not
hold in the case of a hash collision).&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;If you don't follow these rules, you will run into very subtle issues, because
very basic Python operations expect these invariants.&lt;/p&gt;
&lt;p&gt;If you want to be able to mutate an object's properties, you have two
options. First, make the object unhashable (set &lt;code&gt;__hash__ = None&lt;/code&gt;). You won't
be able to use it in sets or as keys to a dictionary, but you will be free to
change the object in-place however you want.&lt;/p&gt;
&lt;p&gt;A second option is to make all mutable properties non-dependent on hashing or
equality testing. This option works well if you just want to cache some
internal state that doesn't inherently change the object. Both &lt;code&gt;__eq__&lt;/code&gt; and
&lt;code&gt;__hash__&lt;/code&gt; should remain unchanged by changes to this state. You may also want
to make sure you use proper getters and setters to prevent modification of
internal state that equality testing and hashing does depend on.&lt;/p&gt;
&lt;p&gt;If you choose this second option, however, be aware that Python considers it
fair game to swap out two identical immutable (i.e., hashable) objects at any
time. If &lt;code&gt;a == b&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; is hashable, Python (and Python libraries) are free
to replace &lt;code&gt;a&lt;/code&gt; with &lt;code&gt;b&lt;/code&gt; anywhere. For example, Python uses an optimization on
strings called &lt;em&gt;interning&lt;/em&gt;, where common strings are stored only once in
memory. A similar optimization is used in CPython for small integers. If store
something on &lt;code&gt;a&lt;/code&gt; but not &lt;code&gt;b&lt;/code&gt; and make &lt;code&gt;a&lt;/code&gt;'s hash ignore that data, you may
find that some function that should return &lt;code&gt;a&lt;/code&gt; may actually return &lt;code&gt;b&lt;/code&gt;. For
this reason, I generally don't recommend this second option unless you know
what you are doing.&lt;/p&gt;
&lt;p&gt;Finally, to keep invariant 2, here are some tips:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Make sure that the parts of the object that you use to compare equality are
not themselves mutable. If they are, then your object cannot itself be
immutable. This means that if &lt;code&gt;a == b&lt;/code&gt; depends on &lt;code&gt;a.attr == b.attr&lt;/code&gt;, and
&lt;code&gt;a.attr&lt;/code&gt; is a list, then you will need to use a tuple instead (if you want
&lt;code&gt;a&lt;/code&gt; to be hashable).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;You don't have to invent a hash function. If you find yourself doing
bitshifts and XORs, you're doing it wrong. Reuse Python's builtin hashable
objects. If the hash of your object should depend on the hash of &lt;code&gt;a&lt;/code&gt; and
&lt;code&gt;b&lt;/code&gt;, define &lt;code&gt;__hash__&lt;/code&gt; to return &lt;code&gt;hash((a, b))&lt;/code&gt;. If the order of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;
does not matter, use &lt;code&gt;hash(frozenset([a, b]))&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Don't cache something unless you know that the entire cached state will not
be changed over the lifetime of the cache. Hashable objects are actually
great for caches. If they properly satisfy invariant 1, and all the state
that should be cached is part of the hash, then you will not need to
worry. And the best part is that you can just use &lt;code&gt;dict&lt;/code&gt; for your cache.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Unless you really need the performance or memory gains, don't make your
objects mutable. This makes programs much harder to reason about. Some
functional programming languages take this idea so far that they don't allow
any mutable objects.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Don't worry about the situation where &lt;code&gt;hash(a) == hash(b)&lt;/code&gt; but &lt;code&gt;a != b&lt;/code&gt;. This is a hash collision. Unlike the issues we looked at here, hash
collisions are expected and checked for in Python. For example, our
&lt;code&gt;HashToOne&lt;/code&gt; object from the beginning will always hash to 1, but different
instances will compare unequal. We can see that the right thing is done in
every case with them.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; a = HashToOne()
&amp;gt;&amp;gt;&amp;gt; b = HashToOne()
&amp;gt;&amp;gt;&amp;gt; a == b
False
&amp;gt;&amp;gt;&amp;gt; hash(a) == hash(b)
True
&amp;gt;&amp;gt;&amp;gt; {a, b}
{&amp;lt;__main__.HashToOne at 0x102c32a10&amp;gt;, &amp;lt;__main__.HashToOne at 0x102c32cd0&amp;gt;}
&amp;gt;&amp;gt;&amp;gt; uniq([a, b])
[&amp;lt;__main__.HashToOne at 0x102c32cd0&amp;gt;, &amp;lt;__main__.HashToOne at 0x102c32a10&amp;gt;]
&amp;gt;&amp;gt;&amp;gt; uniq2([a, b])
[&amp;lt;__main__.HashToOne at 0x102c32cd0&amp;gt;, &amp;lt;__main__.HashToOne at 0x102c32a10&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The only concern with hash collisions is that too many of them can remove
the performance gains of &lt;code&gt;dict&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Conversely, if you are writing something that uses an object's hash, remember
that hash collisions are possible and unavoidable.&lt;/p&gt;
&lt;p&gt;A classic example of a hash collision is &lt;code&gt;-1&lt;/code&gt; and &lt;code&gt;-2&lt;/code&gt;. Remember I
mentioned above that small integers hash to themselves:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; hash(1)
1
&amp;gt;&amp;gt;&amp;gt; hash(-3)
-3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The exception to this is &lt;code&gt;-1&lt;/code&gt;. The CPython interpreter uses &lt;code&gt;-1&lt;/code&gt; as an error
state, so -1 is not a valid hash value. Hence, &lt;code&gt;hash(-1)&lt;/code&gt; can't be &lt;code&gt;-1&lt;/code&gt;. So
the Python developers picked the next closest thing.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; hash(-1)
-2
&amp;gt;&amp;gt;&amp;gt; hash(-2)
-2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you want to check if something handles hash collisions correctly, this is
a simple example.  I should also note that the fact that integers hash to
themselves is an implementation detail of CPython that may not be true in
alternate Python implementations.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Finally, we didn't discuss this much here, but don't assume that the hash of
your object will be the same across Python sessions. In Python 3.3 and up,
hash values of strings are randomized from a value that is seeded when
Python starts up. This also affects any object whose hash is computed
from the hash of strings. In Python 2.7, you can enable hash randomization
with the &lt;code&gt;-R&lt;/code&gt; flag to the interpreter. The following are two different
Python sessions.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; print(hash('a'))
-7750608935454338104
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;&amp;gt;&amp;gt;&amp;gt; print(hash('a'))
8897161376854729812
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</description><category>mathjax</category><guid>https://asmeurer.github.io/blog/posts/what-happens-when-you-mess-with-hashing-in-python/</guid><pubDate>Tue, 26 Jan 2016 04:13:53 GMT</pubDate></item><item><title>Moving to GitHub pages with Nikola</title><link>https://asmeurer.github.io/blog/posts/moving-to-github-pages-with-nikola/</link><dc:creator>Aaron Meurer</dc:creator><description>&lt;div&gt;&lt;p&gt;So I've finally decided to move my blog from Wordpress to GitHub pages.  I
highly recommend it if you are technically skilled enough to do it. I was
getting pretty annoyed at Wordpress. It forces you to write your posts in
html (or else using their WYSIWYG editor), the wordpress.com is locked down,
so you can't add any Javascript, their math is stuck in the past rendering png
instead of using MathJax. The list goes on.&lt;/p&gt;
&lt;p&gt;With GitHub pages, I can write my posts in Markdown, and I have full control
over everything. And there is no lock in. If I decide I don't like the
software that is generating the posts, I can easily move to something else,
since the post content itself is all Markdown (or the occasional rst or
IPython notebook if I want to do something that Markdown doesn't support). I
can use MathJax for math (like \( e^{i\pi} + 1 = 0 \)). Wordpress.com
doesn't let you install abtirary Javascript on your blog, so you can't do
things like install MathJax or enable some cool sidebar thing (like a Twitter
feed).&lt;/p&gt;
&lt;h2&gt;Setting up GitHub Pages&lt;/h2&gt;
&lt;p&gt;First, you need to set up GitHub pages. This is a bit confusing, because there
are actually two kinds of GitHub pages, user pages and project pages. User
pages are if you have a repo named &lt;code&gt;username.github.io&lt;/code&gt; (or &lt;code&gt;.com&lt;/code&gt;). The pages
are served from the &lt;code&gt;master&lt;/code&gt; branch.&lt;/p&gt;
&lt;p&gt;For project pages, you add a &lt;code&gt;gh-pages&lt;/code&gt; branch to any one of your projects,
and GitHub hosts the content automatically at
&lt;code&gt;username.github.io/projectname&lt;/code&gt;. I originally had my blog content at
&lt;code&gt;asmeurer.github.io&lt;/code&gt;, but I didn't like that I had to do everything in master,
both the generated and original content. So instead I created a repo called
&lt;code&gt;blog&lt;/code&gt;. I have my content in the &lt;code&gt;master&lt;/code&gt; branch and the generated pages in
the &lt;code&gt;gh-pages&lt;/code&gt; branch (more on this later). At my
&lt;a href="https://github.com/asmeurer/asmeurer.github.com"&gt;&lt;code&gt;asmeurer.github.com&lt;/code&gt;&lt;/a&gt; repo,
I just have for now a basic redirect to the blog. In the future, I may want to
put additional, non-blog content on the website, and it would go there (or in
a separate project repo with its own &lt;code&gt;gh-pages&lt;/code&gt; branch).&lt;/p&gt;
&lt;h2&gt;Nikola&lt;/h2&gt;
&lt;p&gt;I had initially planned on using
&lt;a href="http://blog.getpelican.com/"&gt;Pelican&lt;/a&gt;. However, I got stalled on the
Wordpress import. I like that Pelican is written in Python, but I was not too
keen on their abrasive
&lt;a href="https://github.com/getpelican/pelican/blob/master/LICENSE"&gt;license&lt;/a&gt;. Frankly,
I shouldn't say too many bad things about Pelican because I never really tried
that hard with it.&lt;/p&gt;
&lt;p&gt;I have decided to try &lt;a href="http://getnikola.com/"&gt;Nikola&lt;/a&gt; instead. It's also
written in Python. It has a very nice
&lt;a href="https://github.com/getnikola/nikola/blob/master/LICENSE.txt"&gt;license&lt;/a&gt;. I like
the philosophy of the &lt;a href="http://getnikola.com/handbook.html"&gt;manual&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;DON'T READ THIS MANUAL. IF YOU NEED TO READ IT I FAILED, JUST USE THE THING.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;I've also discovered that the
&lt;a href="https://groups.google.com/forum/#%21forum/nikola-discuss"&gt;Nikola community&lt;/a&gt; is
&lt;em&gt;very&lt;/em&gt; nice. And of course, even if Nikola ends up not being for me, it will
be easy to switch, because my actual content is just some Markdown files that
I own.&lt;/p&gt;
&lt;h3&gt;Getting started&lt;/h3&gt;
&lt;p&gt;Getting started with Nikola is pretty easy. First, you need to install it. It
has a &lt;em&gt;ton&lt;/em&gt; of dependencies (fortunately all Python, so it won't be that
hard). In addition to the ones in the requirements.txt, you should also
install &lt;code&gt;markdown&lt;/code&gt; and &lt;code&gt;webassets&lt;/code&gt;. While using &lt;code&gt;nikola&lt;/code&gt;, it will tell you if
you don't have something installed that you should, so if you see that, just
install what it tells you to.  If you use &lt;code&gt;conda&lt;/code&gt; and Mac OS X, I have
uploaded all the dependencies to my &lt;a href="https://binstar.org/asmeurer/"&gt;Binstar&lt;/a&gt;,
so you can just &lt;code&gt;conda install -c asmeurer nikola&lt;/code&gt;. Oh and don't worry, Nikola
and its dependencies fully support Python 3 (I wouldn't be using it if they
didn't).&lt;/p&gt;
&lt;p&gt;Then you just run the commands from
http://getnikola.com/handbook.html#all-you-need-to-know.&lt;/p&gt;
&lt;p&gt;One thing that doesn't tell you is that after you init the site, you should
walk through &lt;code&gt;conf.py&lt;/code&gt; and change the settings to your liking.&lt;/p&gt;
&lt;p&gt;Another trick not there is that you can add&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;eval "`nikola tabcompletion`"
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;to your Bash profile to get tab completion.&lt;/p&gt;
&lt;h3&gt;Tricks&lt;/h3&gt;
&lt;p&gt;Here are some useful tricks:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;To enable MathJax, you have to type &lt;code&gt;mathjax&lt;/code&gt; in a line by itself in the
metadata file. There are some bugs right now, but ideally you could do inline
math with &lt;code&gt;$math$&lt;/code&gt; and display math with &lt;code&gt;$$math$$&lt;/code&gt;. &lt;code&gt;$math$&lt;/code&gt; doesn't work
currently, but you can do &lt;code&gt;\\(math\\)&lt;/code&gt; (both &lt;code&gt;\&lt;/code&gt;s are required, although this
is likely a bug). You can do &lt;code&gt;\\[math\\]&lt;/code&gt; for display math.  Here are some
examples. Inline: \( \sin ^2{x} + \cos^2{x} = 1\). Display: $$ e^{i\pi} + 1 = 0 .$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Your one-stop command when blogging is &lt;code&gt;nikola auto&lt;/code&gt;. This requires
&lt;code&gt;livereload&lt;/code&gt;. This will serve the blog on localhost, and automatically
rebuild it when any change is made (and I really mean &lt;em&gt;any&lt;/em&gt; change: it can
even detect when you change Nikola itself).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;I have the following in my conf.py to deploy:&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;DEPLOY_COMMANDS = [
    "git checkout gh-pages",
    "rsync -rPv --delete-after --exclude old_blog --exclude .git --exclude .gitignore --exclude cache/ --exclude .doit.db.db output/ .",
    "git add -A",
    "git commit -a -m 'Updating blog content'",
    "git push",
    "git checkout master",
]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;WARNING: These commands are dangerous. If you don't properly exclude things
like &lt;code&gt;.git&lt;/code&gt;, you will wipe your entire git history. I &lt;em&gt;highly&lt;/em&gt; recommend
committing everything and pushing to GitHub before deploying.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Use&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;_site/
*.pyc
.DS_Store
.doit.db.db
cache/
output/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;for your &lt;code&gt;.gitignore&lt;/code&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Despite what it says on the Nikola page, be sure to read the docs, because
there are a lot of cool features you won't know about unless you read about
them. Also be sure to read through &lt;code&gt;conf.py&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Wordpress import&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;This is something that I am still figuring out. You can see the progress at
&lt;a href="http://asmeurer.github.io/blog/old_blog"&gt;http://asmeurer.github.io/blog/old_blog&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Importing from Wordpress is pretty easy actually (at least in theory). First
you need to go to the Wordpress site dashboard and go to "Export" from the
"Tools" menu. From here you can download an XML file with all your
content. Then just do&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;nikola import_wordpress export_file.xml
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that the current version of Nikola as of this writing (6.3.0) doesn't do
this right, so you'll need to use the
&lt;a href="https://github.com/getnikola/nikola"&gt;git master&lt;/a&gt;. There are some issues with
the import, since Wordpress has its own markup that it doesn't know everything
about, so you may need to go in and fix things. Or report them as bugs to
Nikola and reimport when they are fixed.&lt;/p&gt;
&lt;p&gt;You'll need to go through the posts and make sure that they are rendered
correctly (this is one reason I haven't finished doing it yet).&lt;/p&gt;
&lt;p&gt;For comments, you first need to create a Disqus account, and enable it in your
conf.py. You should then upload the xml file that you exported from Wordpress
to Disqus. At this point, the comments should just work, because Nikola sets
the Disqus url for the imported comments to the old Wordpress url (look at the
Disqus section of one of the built pages).&lt;/p&gt;
&lt;p&gt;I don't know how to automatically backlink from Wordpress back to
Nikola. Maybe I should just automatically generate some links and paste them
in manually.&lt;/p&gt;&lt;/div&gt;</description><category>mathjax</category><guid>https://asmeurer.github.io/blog/posts/moving-to-github-pages-with-nikola/</guid><pubDate>Sun, 09 Feb 2014 23:19:18 GMT</pubDate></item></channel></rss>